D&D Campaign Manager: Live Interaction System Development Plan

---

1. High-Level Architecture

Core Concepts

- Interaction: A session (combat, social, puzzle, etc.) with a set of participants, a map, and a turn order.
- Turn: A discrete opportunity for an entity (PC, NPC, monster) to act.
- Live Server: A tRPC-based backend that orchestrates state, validates moves, and broadcasts updates.
- Convex DB: Source of truth for persistent data; receives finalized interaction logs, outcomes, and state snapshots.

Data Flow

1. Interaction Created: CRUD in Convex.
2. Interaction Goes Live: tRPC server spins up a “room” for the interaction, keeping a persistent in-memory state for the room.
3. Players/DM Connect: Authenticated via Clerk, join the room.
4. Real-Time Play: All moves, chat, and state changes handled by the tRPC server, with state updates sent as deltas.
5. State Snapshots:
	- At the end of each initiative order (when the last entity has acted and the order is about to repeat),
	- When a player/DM disconnects,
	- When an enemy (NPC or monster) or player character is defeated,
	- When a DM disconnects,
	- When an interaction is paused (by the DM),
	- Or when the interaction is completed,
a full state snapshot is saved to Convex, replacing the previous snapshot to avoid DB bloat.
6. Interaction Paused/Completed: In-memory state is written to Convex, which remains the source of truth.
7. Interaction Resumed:
	- If in-memory state exists and the interaction is still live, use it and update clients via deltas.
	- If the interaction is paused or completed, update clients with the snapshot in Convex.
8. Inactive Timeout: If a room is inactive for a configurable period (default 5 minutes, set in a config file), in-memory state is written to Convex and the room is cleared from memory.

---

2. Tech Stack Choices

- Frontend: React + TanStack Query + shadcn/ui
- Auth: Clerk
- Persistence: Convex
- Live Server: tRPC subscriptions (for real-time communication)
- State Management: Zod for validation, Zustand or React Context for local state

---

3. Game Server Design (tRPC)

Room/Session Management

- Each live interaction = a “room” (unique ID, participants, state)
- On “live” state, server creates room, loads initial state from Convex, and maintains in-memory state until paused, completed, or inactive for the configured timeout.
- At the end of each initiative order, on disconnect, when an entity is defeated, when a DM disconnects, or when an interaction is paused or completed, a full state snapshot is saved to Convex, replacing the previous snapshot.

Real-Time Protocol

- Events:
	- joinRoom, leaveRoom
	- startInteraction, pauseInteraction, resumeInteraction, endInteraction
	- takeTurn, queueTurn, skipTurn, backtrackTurn
	- moveEntity, useItem, equipItem, interactObject
	- sendChat
	- updateInitiative
- Broadcasts:
	- stateDelta (only changes since last update)
	- turnUpdate
	- chatMessage
	- logEvent

State Model

- Interaction State: { status, initiativeOrder, currentTurn, map, participants, logs, etc. }
- Turn State: { owner, status, availableActions, mapPosition, etc. }
- Player State: { inventory, actions, chat, etc. }

---

4. Frontend UX Flows

Player

- Modal pops up when interaction is live
- See: inventory, actions, map, initiative order, chat
- Take turn: select action, target, move, use/equip/interact
- Chat: party, DM, private

DM

- Auto-roll initiative
- Take/queue turns for NPCs/monsters
- Skip/backtrack turns
- See turn log/history
- Target multiple players

---

5. Development Phases

Phase 1: MVP Live Server

-  Set up tRPC server with subscriptions
-  Implement room creation/join/leave
-  Sync interaction state (initiative, map, participants)
-  Allow players to take turns, DM to control flow
-  Broadcast state deltas

Phase 2: Turn System

-  Implement turn queue, pending/taken states
-  Validate actions based on entity, inventory, map (all actions validated the same way)
-  DM controls: skip/backtrack, queue NPC/monster turns

Phase 3: Real-Time UX

-  Player modal, action selection, map movement
-  Chat system (party, DM, private)
-  Initiative order display

Phase 4: Persistence & Logging

-  At the end of each initiative order, on disconnect, when an entity is defeated, when a DM disconnects, or when an interaction is paused or completed, save a full state snapshot to Convex (replace previous snapshot).
-  On interaction pause or complete, call a Convex mutation to persist:
	- Final state (map, participants, outcomes)
	- Turn log
	- XP/loot awards
	- Chat log (if desired)
-  Application errors are logged and sent to Convex.

Phase 5: Advanced Features

-  Multi-target actions
-  Dynamic action options per entity
-  Pausing/resuming interactions
-  DM override tools

---

6. Key Challenges & Solutions

A. Error Handling & Edge Cases

- 


Player Disconnects:


	- System notifies other players and DM of disconnect (minimal notification).
	- DM can skip their turn(s).
	- When player reconnects, they can take any missed turns.
	- On disconnect, a full state snapshot is saved to Convex.
- 
DM Disconnects:


	- Players can continue to take and queue their turns.
	- Interaction is paused and awaits DM to resume it live.
	- On disconnect, a full state snapshot is saved to Convex.
- 
Simultaneous Actions:


	- If two clients act for the same entity at once, the first action is accepted.
	- If both are simultaneous, randomly choose one.
	- DM can always roll back a turn.
- 
Inactive Room Timeout:


	- If a room is inactive for a configurable period (default 5 minutes, set in a config file), in-memory state is written to Convex and the room is cleared from memory.

B. Security & Validation

- Users can only act for player characters they have created in the interaction.
- All actions are validated the same way, regardless of user role.

C. State Synchronization & Rejoin

- On reconnect, the client authenticates and checks for any live interactions involving their player character.
- If the interaction is still live and in-memory state exists, update the client via deltas.
- If the interaction is paused or completed, update the client with the snapshot in Convex.
- Server maintains in-memory state for each room while live; on pause, completion, or inactivity, state is written to Convex and memory is cleared.
- Convex is always the source of truth, but in-memory state is used if available and fresh.
- Only the latest snapshot is kept in Convex to avoid DB bloat.

D. Turn/Action Timeouts

- Players have 90 seconds to take their turn.
- If time expires, their turn is skipped (DM can roll back if needed).

E. Logging and Auditing

- Only application errors are logged.
- Logs are sent to Convex.

F. Scalability/Deployment

- For MVP, use a managed Node.js host with WebSocket support (e.g., Railway, Fly.io).
- For production, containerize the application for horizontal scaling and reliability.
- This live server is a separate application from the CRUD Convex web app.

G. Testing and Simulation

- Full end-to-end simulated live interaction test coverage is required.
- Test mode is available to users with the admin role only.

H. Accessibility & Mobile

- All UI must be accessible and support dark mode.
- Accessibility must meet WCAG 2.1 AA standards.
- The system should be as accessible as possible, supporting a wide range of assistive technologies.

I. Extensibility

- Addition of new entities is handled in the CRUD part of the application and is out of scope for the live interaction system.

---

7. Client-Side Changes Required

A. Real-Time Connection

- Integrate tRPC subscriptions for live updates (room join/leave, state deltas, chat, etc.)
- Use Clerk tokens for authentication on all tRPC calls

B. Live Interaction Modal

- Show modal when an interaction with a user’s character goes live
- Display inventory, available actions, action slots, map, initiative order, and chat

C. Turn UI

- Show available actions, targets, and map movement options based on entity state
- Allow (un)equip/use items, interact with objects
- Submit turn actions to tRPC server

D. Chat System

- Implement party chat, DM chat, and private chat
- UI for selecting chat recipients

E. Initiative Order

- Display current initiative order and highlight user’s position

F. DM Controls

- UI for auto-rolling initiative
- Controls for taking/queuing turns for NPCs/monsters
- Skip/backtrack turns (with confirmation)
- View turn log/history
- Multi-target selection UI

G. Rejoin/Disconnect Handling

- On reconnect, rejoin the correct room and sync state (receive state delta or full state from server as appropriate)

H. Rollback/Override

- UI for DM to roll back a turn and allow a redo

I. Accessibility

- All UI must be accessible and support dark mode
- Must meet WCAG 2.1 AA standards
- Should support a wide range of assistive technologies

---

8. Example: tRPC Event Flow

	// Pseudocode for a turn event
	trpc.interaction.takeTurn.mutate({
	  interactionId,
	  entityId,
	  action,
	  target,
	  // ...other action data
	});
	// Server validates, updates state, and broadcasts via subscription (as a delta)


---

9. Next Steps

1. Set up tRPC server with subscriptions
2. Define event protocol and state model
3. Build room/interaction handler with in-memory state and delta broadcasting
4. Integrate with React frontend for live modals and state
5. Test with a simple combat scenario
6. Iterate on client-side UX for all required features
7. Decide on deployment approach for MVP and production