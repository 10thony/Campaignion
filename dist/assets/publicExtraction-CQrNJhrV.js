import{GlobalWorkerOptions as Le,version as Pt}from"./pdf-CHhNo-mi.js";import Nt from"./pdf.worker.min-B8sd9tUL.js";function Mt(){if(typeof window>"u"){Le.workerSrc="";return}try{Le.workerSrc=Nt}catch(s){console.warn("Failed to configure PDF.js worker with unpkg, trying fallback...",s);try{Le.workerSrc=`https://cdn.jsdelivr.net/npm/pdfjs-dist@${Pt}/build/pdf.worker.min.mjs`}catch(e){console.warn("Failed to configure PDF.js worker with jsDelivr, using main thread...",e),Le.workerSrc=""}}}var V;(function(s){s.assertEqual=i=>{};function e(i){}s.assertIs=e;function t(i){throw new Error}s.assertNever=t,s.arrayToEnum=i=>{const a={};for(const r of i)a[r]=r;return a},s.getValidEnumValues=i=>{const a=s.objectKeys(i).filter(o=>typeof i[i[o]]!="number"),r={};for(const o of a)r[o]=i[o];return s.objectValues(r)},s.objectValues=i=>s.objectKeys(i).map(function(a){return i[a]}),s.objectKeys=typeof Object.keys=="function"?i=>Object.keys(i):i=>{const a=[];for(const r in i)Object.prototype.hasOwnProperty.call(i,r)&&a.push(r);return a},s.find=(i,a)=>{for(const r of i)if(a(r))return r},s.isInteger=typeof Number.isInteger=="function"?i=>Number.isInteger(i):i=>typeof i=="number"&&Number.isFinite(i)&&Math.floor(i)===i;function n(i,a=" | "){return i.map(r=>typeof r=="string"?`'${r}'`:r).join(a)}s.joinValues=n,s.jsonStringifyReplacer=(i,a)=>typeof a=="bigint"?a.toString():a})(V||(V={}));var tt;(function(s){s.mergeShapes=(e,t)=>({...e,...t})})(tt||(tt={}));const C=V.arrayToEnum(["string","nan","number","integer","float","boolean","date","bigint","symbol","function","undefined","null","array","object","unknown","promise","void","never","map","set"]),de=s=>{switch(typeof s){case"undefined":return C.undefined;case"string":return C.string;case"number":return Number.isNaN(s)?C.nan:C.number;case"boolean":return C.boolean;case"function":return C.function;case"bigint":return C.bigint;case"symbol":return C.symbol;case"object":return Array.isArray(s)?C.array:s===null?C.null:s.then&&typeof s.then=="function"&&s.catch&&typeof s.catch=="function"?C.promise:typeof Map<"u"&&s instanceof Map?C.map:typeof Set<"u"&&s instanceof Set?C.set:typeof Date<"u"&&s instanceof Date?C.date:C.object;default:return C.unknown}},p=V.arrayToEnum(["invalid_type","invalid_literal","custom","invalid_union","invalid_union_discriminator","invalid_enum_value","unrecognized_keys","invalid_arguments","invalid_return_type","invalid_date","invalid_string","too_small","too_big","invalid_intersection_types","not_multiple_of","not_finite"]);class oe extends Error{get errors(){return this.issues}constructor(e){super(),this.issues=[],this.addIssue=n=>{this.issues=[...this.issues,n]},this.addIssues=(n=[])=>{this.issues=[...this.issues,...n]};const t=new.target.prototype;Object.setPrototypeOf?Object.setPrototypeOf(this,t):this.__proto__=t,this.name="ZodError",this.issues=e}format(e){const t=e||function(a){return a.message},n={_errors:[]},i=a=>{for(const r of a.issues)if(r.code==="invalid_union")r.unionErrors.map(i);else if(r.code==="invalid_return_type")i(r.returnTypeError);else if(r.code==="invalid_arguments")i(r.argumentsError);else if(r.path.length===0)n._errors.push(t(r));else{let o=n,d=0;for(;d<r.path.length;){const c=r.path[d];d===r.path.length-1?(o[c]=o[c]||{_errors:[]},o[c]._errors.push(t(r))):o[c]=o[c]||{_errors:[]},o=o[c],d++}}};return i(this),n}static assert(e){if(!(e instanceof oe))throw new Error(`Not a ZodError: ${e}`)}toString(){return this.message}get message(){return JSON.stringify(this.issues,V.jsonStringifyReplacer,2)}get isEmpty(){return this.issues.length===0}flatten(e=t=>t.message){const t={},n=[];for(const i of this.issues)if(i.path.length>0){const a=i.path[0];t[a]=t[a]||[],t[a].push(e(i))}else n.push(e(i));return{formErrors:n,fieldErrors:t}}get formErrors(){return this.flatten()}}oe.create=s=>new oe(s);const Ve=(s,e)=>{let t;switch(s.code){case p.invalid_type:s.received===C.undefined?t="Required":t=`Expected ${s.expected}, received ${s.received}`;break;case p.invalid_literal:t=`Invalid literal value, expected ${JSON.stringify(s.expected,V.jsonStringifyReplacer)}`;break;case p.unrecognized_keys:t=`Unrecognized key(s) in object: ${V.joinValues(s.keys,", ")}`;break;case p.invalid_union:t="Invalid input";break;case p.invalid_union_discriminator:t=`Invalid discriminator value. Expected ${V.joinValues(s.options)}`;break;case p.invalid_enum_value:t=`Invalid enum value. Expected ${V.joinValues(s.options)}, received '${s.received}'`;break;case p.invalid_arguments:t="Invalid function arguments";break;case p.invalid_return_type:t="Invalid function return type";break;case p.invalid_date:t="Invalid date";break;case p.invalid_string:typeof s.validation=="object"?"includes"in s.validation?(t=`Invalid input: must include "${s.validation.includes}"`,typeof s.validation.position=="number"&&(t=`${t} at one or more positions greater than or equal to ${s.validation.position}`)):"startsWith"in s.validation?t=`Invalid input: must start with "${s.validation.startsWith}"`:"endsWith"in s.validation?t=`Invalid input: must end with "${s.validation.endsWith}"`:V.assertNever(s.validation):s.validation!=="regex"?t=`Invalid ${s.validation}`:t="Invalid";break;case p.too_small:s.type==="array"?t=`Array must contain ${s.exact?"exactly":s.inclusive?"at least":"more than"} ${s.minimum} element(s)`:s.type==="string"?t=`String must contain ${s.exact?"exactly":s.inclusive?"at least":"over"} ${s.minimum} character(s)`:s.type==="number"?t=`Number must be ${s.exact?"exactly equal to ":s.inclusive?"greater than or equal to ":"greater than "}${s.minimum}`:s.type==="bigint"?t=`Number must be ${s.exact?"exactly equal to ":s.inclusive?"greater than or equal to ":"greater than "}${s.minimum}`:s.type==="date"?t=`Date must be ${s.exact?"exactly equal to ":s.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(s.minimum))}`:t="Invalid input";break;case p.too_big:s.type==="array"?t=`Array must contain ${s.exact?"exactly":s.inclusive?"at most":"less than"} ${s.maximum} element(s)`:s.type==="string"?t=`String must contain ${s.exact?"exactly":s.inclusive?"at most":"under"} ${s.maximum} character(s)`:s.type==="number"?t=`Number must be ${s.exact?"exactly":s.inclusive?"less than or equal to":"less than"} ${s.maximum}`:s.type==="bigint"?t=`BigInt must be ${s.exact?"exactly":s.inclusive?"less than or equal to":"less than"} ${s.maximum}`:s.type==="date"?t=`Date must be ${s.exact?"exactly":s.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(s.maximum))}`:t="Invalid input";break;case p.custom:t="Invalid input";break;case p.invalid_intersection_types:t="Intersection results could not be merged";break;case p.not_multiple_of:t=`Number must be a multiple of ${s.multipleOf}`;break;case p.not_finite:t="Number must be finite";break;default:t=e.defaultError,V.assertNever(s)}return{message:t}};let Lt=Ve;function Ot(){return Lt}const Zt=s=>{const{data:e,path:t,errorMaps:n,issueData:i}=s,a=[...t,...i.path||[]],r={...i,path:a};if(i.message!==void 0)return{...i,path:a,message:i.message};let o="";const d=n.filter(c=>!!c).slice().reverse();for(const c of d)o=c(r,{data:e,defaultError:o}).message;return{...i,path:a,message:o}};function b(s,e){const t=Ot(),n=Zt({issueData:e,data:s.data,path:s.path,errorMaps:[s.common.contextualErrorMap,s.schemaErrorMap,t,t===Ve?void 0:Ve].filter(i=>!!i)});s.common.issues.push(n)}class te{constructor(){this.value="valid"}dirty(){this.value==="valid"&&(this.value="dirty")}abort(){this.value!=="aborted"&&(this.value="aborted")}static mergeArray(e,t){const n=[];for(const i of t){if(i.status==="aborted")return R;i.status==="dirty"&&e.dirty(),n.push(i.value)}return{status:e.value,value:n}}static async mergeObjectAsync(e,t){const n=[];for(const i of t){const a=await i.key,r=await i.value;n.push({key:a,value:r})}return te.mergeObjectSync(e,n)}static mergeObjectSync(e,t){const n={};for(const i of t){const{key:a,value:r}=i;if(a.status==="aborted"||r.status==="aborted")return R;a.status==="dirty"&&e.dirty(),r.status==="dirty"&&e.dirty(),a.value!=="__proto__"&&(typeof r.value<"u"||i.alwaysSet)&&(n[a.value]=r.value)}return{status:e.value,value:n}}}const R=Object.freeze({status:"aborted"}),Ee=s=>({status:"dirty",value:s}),se=s=>({status:"valid",value:s}),st=s=>s.status==="aborted",nt=s=>s.status==="dirty",be=s=>s.status==="valid",Ze=s=>typeof Promise<"u"&&s instanceof Promise;var A;(function(s){s.errToObj=e=>typeof e=="string"?{message:e}:e||{},s.toString=e=>typeof e=="string"?e:e==null?void 0:e.message})(A||(A={}));class fe{constructor(e,t,n,i){this._cachedPath=[],this.parent=e,this.data=t,this._path=n,this._key=i}get path(){return this._cachedPath.length||(Array.isArray(this._key)?this._cachedPath.push(...this._path,...this._key):this._cachedPath.push(...this._path,this._key)),this._cachedPath}}const it=(s,e)=>{if(be(e))return{success:!0,data:e.value};if(!s.common.issues.length)throw new Error("Validation failed but no issues detected.");return{success:!1,get error(){if(this._error)return this._error;const t=new oe(s.common.issues);return this._error=t,this._error}}};function z(s){if(!s)return{};const{errorMap:e,invalid_type_error:t,required_error:n,description:i}=s;if(e&&(t||n))throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);return e?{errorMap:e,description:i}:{errorMap:(r,o)=>{const{message:d}=s;return r.code==="invalid_enum_value"?{message:d??o.defaultError}:typeof o.data>"u"?{message:d??n??o.defaultError}:r.code!=="invalid_type"?{message:o.defaultError}:{message:d??t??o.defaultError}},description:i}}class H{get description(){return this._def.description}_getType(e){return de(e.data)}_getOrReturnCtx(e,t){return t||{common:e.parent.common,data:e.data,parsedType:de(e.data),schemaErrorMap:this._def.errorMap,path:e.path,parent:e.parent}}_processInputParams(e){return{status:new te,ctx:{common:e.parent.common,data:e.data,parsedType:de(e.data),schemaErrorMap:this._def.errorMap,path:e.path,parent:e.parent}}}_parseSync(e){const t=this._parse(e);if(Ze(t))throw new Error("Synchronous parse encountered promise.");return t}_parseAsync(e){const t=this._parse(e);return Promise.resolve(t)}parse(e,t){const n=this.safeParse(e,t);if(n.success)return n.data;throw n.error}safeParse(e,t){const n={common:{issues:[],async:(t==null?void 0:t.async)??!1,contextualErrorMap:t==null?void 0:t.errorMap},path:(t==null?void 0:t.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:e,parsedType:de(e)},i=this._parseSync({data:e,path:n.path,parent:n});return it(n,i)}"~validate"(e){var n,i;const t={common:{issues:[],async:!!this["~standard"].async},path:[],schemaErrorMap:this._def.errorMap,parent:null,data:e,parsedType:de(e)};if(!this["~standard"].async)try{const a=this._parseSync({data:e,path:[],parent:t});return be(a)?{value:a.value}:{issues:t.common.issues}}catch(a){(i=(n=a==null?void 0:a.message)==null?void 0:n.toLowerCase())!=null&&i.includes("encountered")&&(this["~standard"].async=!0),t.common={issues:[],async:!0}}return this._parseAsync({data:e,path:[],parent:t}).then(a=>be(a)?{value:a.value}:{issues:t.common.issues})}async parseAsync(e,t){const n=await this.safeParseAsync(e,t);if(n.success)return n.data;throw n.error}async safeParseAsync(e,t){const n={common:{issues:[],contextualErrorMap:t==null?void 0:t.errorMap,async:!0},path:(t==null?void 0:t.path)||[],schemaErrorMap:this._def.errorMap,parent:null,data:e,parsedType:de(e)},i=this._parse({data:e,path:n.path,parent:n}),a=await(Ze(i)?i:Promise.resolve(i));return it(n,a)}refine(e,t){const n=i=>typeof t=="string"||typeof t>"u"?{message:t}:typeof t=="function"?t(i):t;return this._refinement((i,a)=>{const r=e(i),o=()=>a.addIssue({code:p.custom,...n(i)});return typeof Promise<"u"&&r instanceof Promise?r.then(d=>d?!0:(o(),!1)):r?!0:(o(),!1)})}refinement(e,t){return this._refinement((n,i)=>e(n)?!0:(i.addIssue(typeof t=="function"?t(n,i):t),!1))}_refinement(e){return new Ae({schema:this,typeName:P.ZodEffects,effect:{type:"refinement",refinement:e}})}superRefine(e){return this._refinement(e)}constructor(e){this.spa=this.safeParseAsync,this._def=e,this.parse=this.parse.bind(this),this.safeParse=this.safeParse.bind(this),this.parseAsync=this.parseAsync.bind(this),this.safeParseAsync=this.safeParseAsync.bind(this),this.spa=this.spa.bind(this),this.refine=this.refine.bind(this),this.refinement=this.refinement.bind(this),this.superRefine=this.superRefine.bind(this),this.optional=this.optional.bind(this),this.nullable=this.nullable.bind(this),this.nullish=this.nullish.bind(this),this.array=this.array.bind(this),this.promise=this.promise.bind(this),this.or=this.or.bind(this),this.and=this.and.bind(this),this.transform=this.transform.bind(this),this.brand=this.brand.bind(this),this.default=this.default.bind(this),this.catch=this.catch.bind(this),this.describe=this.describe.bind(this),this.pipe=this.pipe.bind(this),this.readonly=this.readonly.bind(this),this.isNullable=this.isNullable.bind(this),this.isOptional=this.isOptional.bind(this),this["~standard"]={version:1,vendor:"zod",validate:t=>this["~validate"](t)}}optional(){return he.create(this,this._def)}nullable(){return Se.create(this,this._def)}nullish(){return this.nullable().optional()}array(){return ie.create(this)}promise(){return je.create(this,this._def)}or(e){return De.create([this,e],this._def)}and(e){return ze.create(this,e,this._def)}transform(e){return new Ae({...z(this._def),schema:this,typeName:P.ZodEffects,effect:{type:"transform",transform:e}})}default(e){const t=typeof e=="function"?e:()=>e;return new Ke({...z(this._def),innerType:this,defaultValue:t,typeName:P.ZodDefault})}brand(){return new rs({typeName:P.ZodBranded,type:this,...z(this._def)})}catch(e){const t=typeof e=="function"?e:()=>e;return new Ye({...z(this._def),innerType:this,catchValue:t,typeName:P.ZodCatch})}describe(e){const t=this.constructor;return new t({...this._def,description:e})}pipe(e){return Qe.create(this,e)}readonly(){return Je.create(this)}isOptional(){return this.safeParse(void 0).success}isNullable(){return this.safeParse(null).success}}const Ft=/^c[^\s-]{8,}$/i,Dt=/^[0-9a-z]+$/,zt=/^[0-9A-HJKMNP-TV-Z]{26}$/i,jt=/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,Bt=/^[a-z0-9_-]{21}$/i,Ht=/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,qt=/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,Vt=/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,Ut="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";let He;const Wt=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,Gt=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,Kt=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,Yt=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,Jt=/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,Qt=/^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,pt="((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",Xt=new RegExp(`^${pt}$`);function gt(s){let e="[0-5]\\d";s.precision?e=`${e}\\.\\d{${s.precision}}`:s.precision==null&&(e=`${e}(\\.\\d+)?`);const t=s.precision?"+":"?";return`([01]\\d|2[0-3]):[0-5]\\d(:${e})${t}`}function es(s){return new RegExp(`^${gt(s)}$`)}function ts(s){let e=`${pt}T${gt(s)}`;const t=[];return t.push(s.local?"Z?":"Z"),s.offset&&t.push("([+-]\\d{2}:?\\d{2})"),e=`${e}(${t.join("|")})`,new RegExp(`^${e}$`)}function ss(s,e){return!!((e==="v4"||!e)&&Wt.test(s)||(e==="v6"||!e)&&Kt.test(s))}function ns(s,e){if(!Ht.test(s))return!1;try{const[t]=s.split(".");if(!t)return!1;const n=t.replace(/-/g,"+").replace(/_/g,"/").padEnd(t.length+(4-t.length%4)%4,"="),i=JSON.parse(atob(n));return!(typeof i!="object"||i===null||"typ"in i&&(i==null?void 0:i.typ)!=="JWT"||!i.alg||e&&i.alg!==e)}catch{return!1}}function is(s,e){return!!((e==="v4"||!e)&&Gt.test(s)||(e==="v6"||!e)&&Yt.test(s))}class ue extends H{_parse(e){if(this._def.coerce&&(e.data=String(e.data)),this._getType(e)!==C.string){const a=this._getOrReturnCtx(e);return b(a,{code:p.invalid_type,expected:C.string,received:a.parsedType}),R}const n=new te;let i;for(const a of this._def.checks)if(a.kind==="min")e.data.length<a.value&&(i=this._getOrReturnCtx(e,i),b(i,{code:p.too_small,minimum:a.value,type:"string",inclusive:!0,exact:!1,message:a.message}),n.dirty());else if(a.kind==="max")e.data.length>a.value&&(i=this._getOrReturnCtx(e,i),b(i,{code:p.too_big,maximum:a.value,type:"string",inclusive:!0,exact:!1,message:a.message}),n.dirty());else if(a.kind==="length"){const r=e.data.length>a.value,o=e.data.length<a.value;(r||o)&&(i=this._getOrReturnCtx(e,i),r?b(i,{code:p.too_big,maximum:a.value,type:"string",inclusive:!0,exact:!0,message:a.message}):o&&b(i,{code:p.too_small,minimum:a.value,type:"string",inclusive:!0,exact:!0,message:a.message}),n.dirty())}else if(a.kind==="email")Vt.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"email",code:p.invalid_string,message:a.message}),n.dirty());else if(a.kind==="emoji")He||(He=new RegExp(Ut,"u")),He.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"emoji",code:p.invalid_string,message:a.message}),n.dirty());else if(a.kind==="uuid")jt.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"uuid",code:p.invalid_string,message:a.message}),n.dirty());else if(a.kind==="nanoid")Bt.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"nanoid",code:p.invalid_string,message:a.message}),n.dirty());else if(a.kind==="cuid")Ft.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"cuid",code:p.invalid_string,message:a.message}),n.dirty());else if(a.kind==="cuid2")Dt.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"cuid2",code:p.invalid_string,message:a.message}),n.dirty());else if(a.kind==="ulid")zt.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"ulid",code:p.invalid_string,message:a.message}),n.dirty());else if(a.kind==="url")try{new URL(e.data)}catch{i=this._getOrReturnCtx(e,i),b(i,{validation:"url",code:p.invalid_string,message:a.message}),n.dirty()}else a.kind==="regex"?(a.regex.lastIndex=0,a.regex.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"regex",code:p.invalid_string,message:a.message}),n.dirty())):a.kind==="trim"?e.data=e.data.trim():a.kind==="includes"?e.data.includes(a.value,a.position)||(i=this._getOrReturnCtx(e,i),b(i,{code:p.invalid_string,validation:{includes:a.value,position:a.position},message:a.message}),n.dirty()):a.kind==="toLowerCase"?e.data=e.data.toLowerCase():a.kind==="toUpperCase"?e.data=e.data.toUpperCase():a.kind==="startsWith"?e.data.startsWith(a.value)||(i=this._getOrReturnCtx(e,i),b(i,{code:p.invalid_string,validation:{startsWith:a.value},message:a.message}),n.dirty()):a.kind==="endsWith"?e.data.endsWith(a.value)||(i=this._getOrReturnCtx(e,i),b(i,{code:p.invalid_string,validation:{endsWith:a.value},message:a.message}),n.dirty()):a.kind==="datetime"?ts(a).test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{code:p.invalid_string,validation:"datetime",message:a.message}),n.dirty()):a.kind==="date"?Xt.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{code:p.invalid_string,validation:"date",message:a.message}),n.dirty()):a.kind==="time"?es(a).test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{code:p.invalid_string,validation:"time",message:a.message}),n.dirty()):a.kind==="duration"?qt.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"duration",code:p.invalid_string,message:a.message}),n.dirty()):a.kind==="ip"?ss(e.data,a.version)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"ip",code:p.invalid_string,message:a.message}),n.dirty()):a.kind==="jwt"?ns(e.data,a.alg)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"jwt",code:p.invalid_string,message:a.message}),n.dirty()):a.kind==="cidr"?is(e.data,a.version)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"cidr",code:p.invalid_string,message:a.message}),n.dirty()):a.kind==="base64"?Jt.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"base64",code:p.invalid_string,message:a.message}),n.dirty()):a.kind==="base64url"?Qt.test(e.data)||(i=this._getOrReturnCtx(e,i),b(i,{validation:"base64url",code:p.invalid_string,message:a.message}),n.dirty()):V.assertNever(a);return{status:n.value,value:e.data}}_regex(e,t,n){return this.refinement(i=>e.test(i),{validation:t,code:p.invalid_string,...A.errToObj(n)})}_addCheck(e){return new ue({...this._def,checks:[...this._def.checks,e]})}email(e){return this._addCheck({kind:"email",...A.errToObj(e)})}url(e){return this._addCheck({kind:"url",...A.errToObj(e)})}emoji(e){return this._addCheck({kind:"emoji",...A.errToObj(e)})}uuid(e){return this._addCheck({kind:"uuid",...A.errToObj(e)})}nanoid(e){return this._addCheck({kind:"nanoid",...A.errToObj(e)})}cuid(e){return this._addCheck({kind:"cuid",...A.errToObj(e)})}cuid2(e){return this._addCheck({kind:"cuid2",...A.errToObj(e)})}ulid(e){return this._addCheck({kind:"ulid",...A.errToObj(e)})}base64(e){return this._addCheck({kind:"base64",...A.errToObj(e)})}base64url(e){return this._addCheck({kind:"base64url",...A.errToObj(e)})}jwt(e){return this._addCheck({kind:"jwt",...A.errToObj(e)})}ip(e){return this._addCheck({kind:"ip",...A.errToObj(e)})}cidr(e){return this._addCheck({kind:"cidr",...A.errToObj(e)})}datetime(e){return typeof e=="string"?this._addCheck({kind:"datetime",precision:null,offset:!1,local:!1,message:e}):this._addCheck({kind:"datetime",precision:typeof(e==null?void 0:e.precision)>"u"?null:e==null?void 0:e.precision,offset:(e==null?void 0:e.offset)??!1,local:(e==null?void 0:e.local)??!1,...A.errToObj(e==null?void 0:e.message)})}date(e){return this._addCheck({kind:"date",message:e})}time(e){return typeof e=="string"?this._addCheck({kind:"time",precision:null,message:e}):this._addCheck({kind:"time",precision:typeof(e==null?void 0:e.precision)>"u"?null:e==null?void 0:e.precision,...A.errToObj(e==null?void 0:e.message)})}duration(e){return this._addCheck({kind:"duration",...A.errToObj(e)})}regex(e,t){return this._addCheck({kind:"regex",regex:e,...A.errToObj(t)})}includes(e,t){return this._addCheck({kind:"includes",value:e,position:t==null?void 0:t.position,...A.errToObj(t==null?void 0:t.message)})}startsWith(e,t){return this._addCheck({kind:"startsWith",value:e,...A.errToObj(t)})}endsWith(e,t){return this._addCheck({kind:"endsWith",value:e,...A.errToObj(t)})}min(e,t){return this._addCheck({kind:"min",value:e,...A.errToObj(t)})}max(e,t){return this._addCheck({kind:"max",value:e,...A.errToObj(t)})}length(e,t){return this._addCheck({kind:"length",value:e,...A.errToObj(t)})}nonempty(e){return this.min(1,A.errToObj(e))}trim(){return new ue({...this._def,checks:[...this._def.checks,{kind:"trim"}]})}toLowerCase(){return new ue({...this._def,checks:[...this._def.checks,{kind:"toLowerCase"}]})}toUpperCase(){return new ue({...this._def,checks:[...this._def.checks,{kind:"toUpperCase"}]})}get isDatetime(){return!!this._def.checks.find(e=>e.kind==="datetime")}get isDate(){return!!this._def.checks.find(e=>e.kind==="date")}get isTime(){return!!this._def.checks.find(e=>e.kind==="time")}get isDuration(){return!!this._def.checks.find(e=>e.kind==="duration")}get isEmail(){return!!this._def.checks.find(e=>e.kind==="email")}get isURL(){return!!this._def.checks.find(e=>e.kind==="url")}get isEmoji(){return!!this._def.checks.find(e=>e.kind==="emoji")}get isUUID(){return!!this._def.checks.find(e=>e.kind==="uuid")}get isNANOID(){return!!this._def.checks.find(e=>e.kind==="nanoid")}get isCUID(){return!!this._def.checks.find(e=>e.kind==="cuid")}get isCUID2(){return!!this._def.checks.find(e=>e.kind==="cuid2")}get isULID(){return!!this._def.checks.find(e=>e.kind==="ulid")}get isIP(){return!!this._def.checks.find(e=>e.kind==="ip")}get isCIDR(){return!!this._def.checks.find(e=>e.kind==="cidr")}get isBase64(){return!!this._def.checks.find(e=>e.kind==="base64")}get isBase64url(){return!!this._def.checks.find(e=>e.kind==="base64url")}get minLength(){let e=null;for(const t of this._def.checks)t.kind==="min"&&(e===null||t.value>e)&&(e=t.value);return e}get maxLength(){let e=null;for(const t of this._def.checks)t.kind==="max"&&(e===null||t.value<e)&&(e=t.value);return e}}ue.create=s=>new ue({checks:[],typeName:P.ZodString,coerce:(s==null?void 0:s.coerce)??!1,...z(s)});function as(s,e){const t=(s.toString().split(".")[1]||"").length,n=(e.toString().split(".")[1]||"").length,i=t>n?t:n,a=Number.parseInt(s.toFixed(i).replace(".","")),r=Number.parseInt(e.toFixed(i).replace(".",""));return a%r/10**i}class _e extends H{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte,this.step=this.multipleOf}_parse(e){if(this._def.coerce&&(e.data=Number(e.data)),this._getType(e)!==C.number){const a=this._getOrReturnCtx(e);return b(a,{code:p.invalid_type,expected:C.number,received:a.parsedType}),R}let n;const i=new te;for(const a of this._def.checks)a.kind==="int"?V.isInteger(e.data)||(n=this._getOrReturnCtx(e,n),b(n,{code:p.invalid_type,expected:"integer",received:"float",message:a.message}),i.dirty()):a.kind==="min"?(a.inclusive?e.data<a.value:e.data<=a.value)&&(n=this._getOrReturnCtx(e,n),b(n,{code:p.too_small,minimum:a.value,type:"number",inclusive:a.inclusive,exact:!1,message:a.message}),i.dirty()):a.kind==="max"?(a.inclusive?e.data>a.value:e.data>=a.value)&&(n=this._getOrReturnCtx(e,n),b(n,{code:p.too_big,maximum:a.value,type:"number",inclusive:a.inclusive,exact:!1,message:a.message}),i.dirty()):a.kind==="multipleOf"?as(e.data,a.value)!==0&&(n=this._getOrReturnCtx(e,n),b(n,{code:p.not_multiple_of,multipleOf:a.value,message:a.message}),i.dirty()):a.kind==="finite"?Number.isFinite(e.data)||(n=this._getOrReturnCtx(e,n),b(n,{code:p.not_finite,message:a.message}),i.dirty()):V.assertNever(a);return{status:i.value,value:e.data}}gte(e,t){return this.setLimit("min",e,!0,A.toString(t))}gt(e,t){return this.setLimit("min",e,!1,A.toString(t))}lte(e,t){return this.setLimit("max",e,!0,A.toString(t))}lt(e,t){return this.setLimit("max",e,!1,A.toString(t))}setLimit(e,t,n,i){return new _e({...this._def,checks:[...this._def.checks,{kind:e,value:t,inclusive:n,message:A.toString(i)}]})}_addCheck(e){return new _e({...this._def,checks:[...this._def.checks,e]})}int(e){return this._addCheck({kind:"int",message:A.toString(e)})}positive(e){return this._addCheck({kind:"min",value:0,inclusive:!1,message:A.toString(e)})}negative(e){return this._addCheck({kind:"max",value:0,inclusive:!1,message:A.toString(e)})}nonpositive(e){return this._addCheck({kind:"max",value:0,inclusive:!0,message:A.toString(e)})}nonnegative(e){return this._addCheck({kind:"min",value:0,inclusive:!0,message:A.toString(e)})}multipleOf(e,t){return this._addCheck({kind:"multipleOf",value:e,message:A.toString(t)})}finite(e){return this._addCheck({kind:"finite",message:A.toString(e)})}safe(e){return this._addCheck({kind:"min",inclusive:!0,value:Number.MIN_SAFE_INTEGER,message:A.toString(e)})._addCheck({kind:"max",inclusive:!0,value:Number.MAX_SAFE_INTEGER,message:A.toString(e)})}get minValue(){let e=null;for(const t of this._def.checks)t.kind==="min"&&(e===null||t.value>e)&&(e=t.value);return e}get maxValue(){let e=null;for(const t of this._def.checks)t.kind==="max"&&(e===null||t.value<e)&&(e=t.value);return e}get isInt(){return!!this._def.checks.find(e=>e.kind==="int"||e.kind==="multipleOf"&&V.isInteger(e.value))}get isFinite(){let e=null,t=null;for(const n of this._def.checks){if(n.kind==="finite"||n.kind==="int"||n.kind==="multipleOf")return!0;n.kind==="min"?(t===null||n.value>t)&&(t=n.value):n.kind==="max"&&(e===null||n.value<e)&&(e=n.value)}return Number.isFinite(t)&&Number.isFinite(e)}}_e.create=s=>new _e({checks:[],typeName:P.ZodNumber,coerce:(s==null?void 0:s.coerce)||!1,...z(s)});class Re extends H{constructor(){super(...arguments),this.min=this.gte,this.max=this.lte}_parse(e){if(this._def.coerce)try{e.data=BigInt(e.data)}catch{return this._getInvalidInput(e)}if(this._getType(e)!==C.bigint)return this._getInvalidInput(e);let n;const i=new te;for(const a of this._def.checks)a.kind==="min"?(a.inclusive?e.data<a.value:e.data<=a.value)&&(n=this._getOrReturnCtx(e,n),b(n,{code:p.too_small,type:"bigint",minimum:a.value,inclusive:a.inclusive,message:a.message}),i.dirty()):a.kind==="max"?(a.inclusive?e.data>a.value:e.data>=a.value)&&(n=this._getOrReturnCtx(e,n),b(n,{code:p.too_big,type:"bigint",maximum:a.value,inclusive:a.inclusive,message:a.message}),i.dirty()):a.kind==="multipleOf"?e.data%a.value!==BigInt(0)&&(n=this._getOrReturnCtx(e,n),b(n,{code:p.not_multiple_of,multipleOf:a.value,message:a.message}),i.dirty()):V.assertNever(a);return{status:i.value,value:e.data}}_getInvalidInput(e){const t=this._getOrReturnCtx(e);return b(t,{code:p.invalid_type,expected:C.bigint,received:t.parsedType}),R}gte(e,t){return this.setLimit("min",e,!0,A.toString(t))}gt(e,t){return this.setLimit("min",e,!1,A.toString(t))}lte(e,t){return this.setLimit("max",e,!0,A.toString(t))}lt(e,t){return this.setLimit("max",e,!1,A.toString(t))}setLimit(e,t,n,i){return new Re({...this._def,checks:[...this._def.checks,{kind:e,value:t,inclusive:n,message:A.toString(i)}]})}_addCheck(e){return new Re({...this._def,checks:[...this._def.checks,e]})}positive(e){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!1,message:A.toString(e)})}negative(e){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!1,message:A.toString(e)})}nonpositive(e){return this._addCheck({kind:"max",value:BigInt(0),inclusive:!0,message:A.toString(e)})}nonnegative(e){return this._addCheck({kind:"min",value:BigInt(0),inclusive:!0,message:A.toString(e)})}multipleOf(e,t){return this._addCheck({kind:"multipleOf",value:e,message:A.toString(t)})}get minValue(){let e=null;for(const t of this._def.checks)t.kind==="min"&&(e===null||t.value>e)&&(e=t.value);return e}get maxValue(){let e=null;for(const t of this._def.checks)t.kind==="max"&&(e===null||t.value<e)&&(e=t.value);return e}}Re.create=s=>new Re({checks:[],typeName:P.ZodBigInt,coerce:(s==null?void 0:s.coerce)??!1,...z(s)});class Ue extends H{_parse(e){if(this._def.coerce&&(e.data=!!e.data),this._getType(e)!==C.boolean){const n=this._getOrReturnCtx(e);return b(n,{code:p.invalid_type,expected:C.boolean,received:n.parsedType}),R}return se(e.data)}}Ue.create=s=>new Ue({typeName:P.ZodBoolean,coerce:(s==null?void 0:s.coerce)||!1,...z(s)});class Fe extends H{_parse(e){if(this._def.coerce&&(e.data=new Date(e.data)),this._getType(e)!==C.date){const a=this._getOrReturnCtx(e);return b(a,{code:p.invalid_type,expected:C.date,received:a.parsedType}),R}if(Number.isNaN(e.data.getTime())){const a=this._getOrReturnCtx(e);return b(a,{code:p.invalid_date}),R}const n=new te;let i;for(const a of this._def.checks)a.kind==="min"?e.data.getTime()<a.value&&(i=this._getOrReturnCtx(e,i),b(i,{code:p.too_small,message:a.message,inclusive:!0,exact:!1,minimum:a.value,type:"date"}),n.dirty()):a.kind==="max"?e.data.getTime()>a.value&&(i=this._getOrReturnCtx(e,i),b(i,{code:p.too_big,message:a.message,inclusive:!0,exact:!1,maximum:a.value,type:"date"}),n.dirty()):V.assertNever(a);return{status:n.value,value:new Date(e.data.getTime())}}_addCheck(e){return new Fe({...this._def,checks:[...this._def.checks,e]})}min(e,t){return this._addCheck({kind:"min",value:e.getTime(),message:A.toString(t)})}max(e,t){return this._addCheck({kind:"max",value:e.getTime(),message:A.toString(t)})}get minDate(){let e=null;for(const t of this._def.checks)t.kind==="min"&&(e===null||t.value>e)&&(e=t.value);return e!=null?new Date(e):null}get maxDate(){let e=null;for(const t of this._def.checks)t.kind==="max"&&(e===null||t.value<e)&&(e=t.value);return e!=null?new Date(e):null}}Fe.create=s=>new Fe({checks:[],coerce:(s==null?void 0:s.coerce)||!1,typeName:P.ZodDate,...z(s)});class at extends H{_parse(e){if(this._getType(e)!==C.symbol){const n=this._getOrReturnCtx(e);return b(n,{code:p.invalid_type,expected:C.symbol,received:n.parsedType}),R}return se(e.data)}}at.create=s=>new at({typeName:P.ZodSymbol,...z(s)});class rt extends H{_parse(e){if(this._getType(e)!==C.undefined){const n=this._getOrReturnCtx(e);return b(n,{code:p.invalid_type,expected:C.undefined,received:n.parsedType}),R}return se(e.data)}}rt.create=s=>new rt({typeName:P.ZodUndefined,...z(s)});class ot extends H{_parse(e){if(this._getType(e)!==C.null){const n=this._getOrReturnCtx(e);return b(n,{code:p.invalid_type,expected:C.null,received:n.parsedType}),R}return se(e.data)}}ot.create=s=>new ot({typeName:P.ZodNull,...z(s)});class We extends H{constructor(){super(...arguments),this._any=!0}_parse(e){return se(e.data)}}We.create=s=>new We({typeName:P.ZodAny,...z(s)});class ct extends H{constructor(){super(...arguments),this._unknown=!0}_parse(e){return se(e.data)}}ct.create=s=>new ct({typeName:P.ZodUnknown,...z(s)});class me extends H{_parse(e){const t=this._getOrReturnCtx(e);return b(t,{code:p.invalid_type,expected:C.never,received:t.parsedType}),R}}me.create=s=>new me({typeName:P.ZodNever,...z(s)});class lt extends H{_parse(e){if(this._getType(e)!==C.undefined){const n=this._getOrReturnCtx(e);return b(n,{code:p.invalid_type,expected:C.void,received:n.parsedType}),R}return se(e.data)}}lt.create=s=>new lt({typeName:P.ZodVoid,...z(s)});class ie extends H{_parse(e){const{ctx:t,status:n}=this._processInputParams(e),i=this._def;if(t.parsedType!==C.array)return b(t,{code:p.invalid_type,expected:C.array,received:t.parsedType}),R;if(i.exactLength!==null){const r=t.data.length>i.exactLength.value,o=t.data.length<i.exactLength.value;(r||o)&&(b(t,{code:r?p.too_big:p.too_small,minimum:o?i.exactLength.value:void 0,maximum:r?i.exactLength.value:void 0,type:"array",inclusive:!0,exact:!0,message:i.exactLength.message}),n.dirty())}if(i.minLength!==null&&t.data.length<i.minLength.value&&(b(t,{code:p.too_small,minimum:i.minLength.value,type:"array",inclusive:!0,exact:!1,message:i.minLength.message}),n.dirty()),i.maxLength!==null&&t.data.length>i.maxLength.value&&(b(t,{code:p.too_big,maximum:i.maxLength.value,type:"array",inclusive:!0,exact:!1,message:i.maxLength.message}),n.dirty()),t.common.async)return Promise.all([...t.data].map((r,o)=>i.type._parseAsync(new fe(t,r,t.path,o)))).then(r=>te.mergeArray(n,r));const a=[...t.data].map((r,o)=>i.type._parseSync(new fe(t,r,t.path,o)));return te.mergeArray(n,a)}get element(){return this._def.type}min(e,t){return new ie({...this._def,minLength:{value:e,message:A.toString(t)}})}max(e,t){return new ie({...this._def,maxLength:{value:e,message:A.toString(t)}})}length(e,t){return new ie({...this._def,exactLength:{value:e,message:A.toString(t)}})}nonempty(e){return this.min(1,e)}}ie.create=(s,e)=>new ie({type:s,minLength:null,maxLength:null,exactLength:null,typeName:P.ZodArray,...z(e)});function ve(s){if(s instanceof J){const e={};for(const t in s.shape){const n=s.shape[t];e[t]=he.create(ve(n))}return new J({...s._def,shape:()=>e})}else return s instanceof ie?new ie({...s._def,type:ve(s.element)}):s instanceof he?he.create(ve(s.unwrap())):s instanceof Se?Se.create(ve(s.unwrap())):s instanceof pe?pe.create(s.items.map(e=>ve(e))):s}class J extends H{constructor(){super(...arguments),this._cached=null,this.nonstrict=this.passthrough,this.augment=this.extend}_getCached(){if(this._cached!==null)return this._cached;const e=this._def.shape(),t=V.objectKeys(e);return this._cached={shape:e,keys:t},this._cached}_parse(e){if(this._getType(e)!==C.object){const c=this._getOrReturnCtx(e);return b(c,{code:p.invalid_type,expected:C.object,received:c.parsedType}),R}const{status:n,ctx:i}=this._processInputParams(e),{shape:a,keys:r}=this._getCached(),o=[];if(!(this._def.catchall instanceof me&&this._def.unknownKeys==="strip"))for(const c in i.data)r.includes(c)||o.push(c);const d=[];for(const c of r){const l=a[c],m=i.data[c];d.push({key:{status:"valid",value:c},value:l._parse(new fe(i,m,i.path,c)),alwaysSet:c in i.data})}if(this._def.catchall instanceof me){const c=this._def.unknownKeys;if(c==="passthrough")for(const l of o)d.push({key:{status:"valid",value:l},value:{status:"valid",value:i.data[l]}});else if(c==="strict")o.length>0&&(b(i,{code:p.unrecognized_keys,keys:o}),n.dirty());else if(c!=="strip")throw new Error("Internal ZodObject error: invalid unknownKeys value.")}else{const c=this._def.catchall;for(const l of o){const m=i.data[l];d.push({key:{status:"valid",value:l},value:c._parse(new fe(i,m,i.path,l)),alwaysSet:l in i.data})}}return i.common.async?Promise.resolve().then(async()=>{const c=[];for(const l of d){const m=await l.key,u=await l.value;c.push({key:m,value:u,alwaysSet:l.alwaysSet})}return c}).then(c=>te.mergeObjectSync(n,c)):te.mergeObjectSync(n,d)}get shape(){return this._def.shape()}strict(e){return A.errToObj,new J({...this._def,unknownKeys:"strict",...e!==void 0?{errorMap:(t,n)=>{var a,r;const i=((r=(a=this._def).errorMap)==null?void 0:r.call(a,t,n).message)??n.defaultError;return t.code==="unrecognized_keys"?{message:A.errToObj(e).message??i}:{message:i}}}:{}})}strip(){return new J({...this._def,unknownKeys:"strip"})}passthrough(){return new J({...this._def,unknownKeys:"passthrough"})}extend(e){return new J({...this._def,shape:()=>({...this._def.shape(),...e})})}merge(e){return new J({unknownKeys:e._def.unknownKeys,catchall:e._def.catchall,shape:()=>({...this._def.shape(),...e._def.shape()}),typeName:P.ZodObject})}setKey(e,t){return this.augment({[e]:t})}catchall(e){return new J({...this._def,catchall:e})}pick(e){const t={};for(const n of V.objectKeys(e))e[n]&&this.shape[n]&&(t[n]=this.shape[n]);return new J({...this._def,shape:()=>t})}omit(e){const t={};for(const n of V.objectKeys(this.shape))e[n]||(t[n]=this.shape[n]);return new J({...this._def,shape:()=>t})}deepPartial(){return ve(this)}partial(e){const t={};for(const n of V.objectKeys(this.shape)){const i=this.shape[n];e&&!e[n]?t[n]=i:t[n]=i.optional()}return new J({...this._def,shape:()=>t})}required(e){const t={};for(const n of V.objectKeys(this.shape))if(e&&!e[n])t[n]=this.shape[n];else{let a=this.shape[n];for(;a instanceof he;)a=a._def.innerType;t[n]=a}return new J({...this._def,shape:()=>t})}keyof(){return yt(V.objectKeys(this.shape))}}J.create=(s,e)=>new J({shape:()=>s,unknownKeys:"strip",catchall:me.create(),typeName:P.ZodObject,...z(e)});J.strictCreate=(s,e)=>new J({shape:()=>s,unknownKeys:"strict",catchall:me.create(),typeName:P.ZodObject,...z(e)});J.lazycreate=(s,e)=>new J({shape:s,unknownKeys:"strip",catchall:me.create(),typeName:P.ZodObject,...z(e)});class De extends H{_parse(e){const{ctx:t}=this._processInputParams(e),n=this._def.options;function i(a){for(const o of a)if(o.result.status==="valid")return o.result;for(const o of a)if(o.result.status==="dirty")return t.common.issues.push(...o.ctx.common.issues),o.result;const r=a.map(o=>new oe(o.ctx.common.issues));return b(t,{code:p.invalid_union,unionErrors:r}),R}if(t.common.async)return Promise.all(n.map(async a=>{const r={...t,common:{...t.common,issues:[]},parent:null};return{result:await a._parseAsync({data:t.data,path:t.path,parent:r}),ctx:r}})).then(i);{let a;const r=[];for(const d of n){const c={...t,common:{...t.common,issues:[]},parent:null},l=d._parseSync({data:t.data,path:t.path,parent:c});if(l.status==="valid")return l;l.status==="dirty"&&!a&&(a={result:l,ctx:c}),c.common.issues.length&&r.push(c.common.issues)}if(a)return t.common.issues.push(...a.ctx.common.issues),a.result;const o=r.map(d=>new oe(d));return b(t,{code:p.invalid_union,unionErrors:o}),R}}get options(){return this._def.options}}De.create=(s,e)=>new De({options:s,typeName:P.ZodUnion,...z(e)});function Ge(s,e){const t=de(s),n=de(e);if(s===e)return{valid:!0,data:s};if(t===C.object&&n===C.object){const i=V.objectKeys(e),a=V.objectKeys(s).filter(o=>i.indexOf(o)!==-1),r={...s,...e};for(const o of a){const d=Ge(s[o],e[o]);if(!d.valid)return{valid:!1};r[o]=d.data}return{valid:!0,data:r}}else if(t===C.array&&n===C.array){if(s.length!==e.length)return{valid:!1};const i=[];for(let a=0;a<s.length;a++){const r=s[a],o=e[a],d=Ge(r,o);if(!d.valid)return{valid:!1};i.push(d.data)}return{valid:!0,data:i}}else return t===C.date&&n===C.date&&+s==+e?{valid:!0,data:s}:{valid:!1}}class ze extends H{_parse(e){const{status:t,ctx:n}=this._processInputParams(e),i=(a,r)=>{if(st(a)||st(r))return R;const o=Ge(a.value,r.value);return o.valid?((nt(a)||nt(r))&&t.dirty(),{status:t.value,value:o.data}):(b(n,{code:p.invalid_intersection_types}),R)};return n.common.async?Promise.all([this._def.left._parseAsync({data:n.data,path:n.path,parent:n}),this._def.right._parseAsync({data:n.data,path:n.path,parent:n})]).then(([a,r])=>i(a,r)):i(this._def.left._parseSync({data:n.data,path:n.path,parent:n}),this._def.right._parseSync({data:n.data,path:n.path,parent:n}))}}ze.create=(s,e,t)=>new ze({left:s,right:e,typeName:P.ZodIntersection,...z(t)});class pe extends H{_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.parsedType!==C.array)return b(n,{code:p.invalid_type,expected:C.array,received:n.parsedType}),R;if(n.data.length<this._def.items.length)return b(n,{code:p.too_small,minimum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),R;!this._def.rest&&n.data.length>this._def.items.length&&(b(n,{code:p.too_big,maximum:this._def.items.length,inclusive:!0,exact:!1,type:"array"}),t.dirty());const a=[...n.data].map((r,o)=>{const d=this._def.items[o]||this._def.rest;return d?d._parse(new fe(n,r,n.path,o)):null}).filter(r=>!!r);return n.common.async?Promise.all(a).then(r=>te.mergeArray(t,r)):te.mergeArray(t,a)}get items(){return this._def.items}rest(e){return new pe({...this._def,rest:e})}}pe.create=(s,e)=>{if(!Array.isArray(s))throw new Error("You must pass an array of schemas to z.tuple([ ... ])");return new pe({items:s,typeName:P.ZodTuple,rest:null,...z(e)})};class dt extends H{get keySchema(){return this._def.keyType}get valueSchema(){return this._def.valueType}_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.parsedType!==C.map)return b(n,{code:p.invalid_type,expected:C.map,received:n.parsedType}),R;const i=this._def.keyType,a=this._def.valueType,r=[...n.data.entries()].map(([o,d],c)=>({key:i._parse(new fe(n,o,n.path,[c,"key"])),value:a._parse(new fe(n,d,n.path,[c,"value"]))}));if(n.common.async){const o=new Map;return Promise.resolve().then(async()=>{for(const d of r){const c=await d.key,l=await d.value;if(c.status==="aborted"||l.status==="aborted")return R;(c.status==="dirty"||l.status==="dirty")&&t.dirty(),o.set(c.value,l.value)}return{status:t.value,value:o}})}else{const o=new Map;for(const d of r){const c=d.key,l=d.value;if(c.status==="aborted"||l.status==="aborted")return R;(c.status==="dirty"||l.status==="dirty")&&t.dirty(),o.set(c.value,l.value)}return{status:t.value,value:o}}}}dt.create=(s,e,t)=>new dt({valueType:e,keyType:s,typeName:P.ZodMap,...z(t)});class Pe extends H{_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.parsedType!==C.set)return b(n,{code:p.invalid_type,expected:C.set,received:n.parsedType}),R;const i=this._def;i.minSize!==null&&n.data.size<i.minSize.value&&(b(n,{code:p.too_small,minimum:i.minSize.value,type:"set",inclusive:!0,exact:!1,message:i.minSize.message}),t.dirty()),i.maxSize!==null&&n.data.size>i.maxSize.value&&(b(n,{code:p.too_big,maximum:i.maxSize.value,type:"set",inclusive:!0,exact:!1,message:i.maxSize.message}),t.dirty());const a=this._def.valueType;function r(d){const c=new Set;for(const l of d){if(l.status==="aborted")return R;l.status==="dirty"&&t.dirty(),c.add(l.value)}return{status:t.value,value:c}}const o=[...n.data.values()].map((d,c)=>a._parse(new fe(n,d,n.path,c)));return n.common.async?Promise.all(o).then(d=>r(d)):r(o)}min(e,t){return new Pe({...this._def,minSize:{value:e,message:A.toString(t)}})}max(e,t){return new Pe({...this._def,maxSize:{value:e,message:A.toString(t)}})}size(e,t){return this.min(e,t).max(e,t)}nonempty(e){return this.min(1,e)}}Pe.create=(s,e)=>new Pe({valueType:s,minSize:null,maxSize:null,typeName:P.ZodSet,...z(e)});class ut extends H{get schema(){return this._def.getter()}_parse(e){const{ctx:t}=this._processInputParams(e);return this._def.getter()._parse({data:t.data,path:t.path,parent:t})}}ut.create=(s,e)=>new ut({getter:s,typeName:P.ZodLazy,...z(e)});class ht extends H{_parse(e){if(e.data!==this._def.value){const t=this._getOrReturnCtx(e);return b(t,{received:t.data,code:p.invalid_literal,expected:this._def.value}),R}return{status:"valid",value:e.data}}get value(){return this._def.value}}ht.create=(s,e)=>new ht({value:s,typeName:P.ZodLiteral,...z(e)});function yt(s,e){return new Ce({values:s,typeName:P.ZodEnum,...z(e)})}class Ce extends H{_parse(e){if(typeof e.data!="string"){const t=this._getOrReturnCtx(e),n=this._def.values;return b(t,{expected:V.joinValues(n),received:t.parsedType,code:p.invalid_type}),R}if(this._cache||(this._cache=new Set(this._def.values)),!this._cache.has(e.data)){const t=this._getOrReturnCtx(e),n=this._def.values;return b(t,{received:t.data,code:p.invalid_enum_value,options:n}),R}return se(e.data)}get options(){return this._def.values}get enum(){const e={};for(const t of this._def.values)e[t]=t;return e}get Values(){const e={};for(const t of this._def.values)e[t]=t;return e}get Enum(){const e={};for(const t of this._def.values)e[t]=t;return e}extract(e,t=this._def){return Ce.create(e,{...this._def,...t})}exclude(e,t=this._def){return Ce.create(this.options.filter(n=>!e.includes(n)),{...this._def,...t})}}Ce.create=yt;class ft extends H{_parse(e){const t=V.getValidEnumValues(this._def.values),n=this._getOrReturnCtx(e);if(n.parsedType!==C.string&&n.parsedType!==C.number){const i=V.objectValues(t);return b(n,{expected:V.joinValues(i),received:n.parsedType,code:p.invalid_type}),R}if(this._cache||(this._cache=new Set(V.getValidEnumValues(this._def.values))),!this._cache.has(e.data)){const i=V.objectValues(t);return b(n,{received:n.data,code:p.invalid_enum_value,options:i}),R}return se(e.data)}get enum(){return this._def.values}}ft.create=(s,e)=>new ft({values:s,typeName:P.ZodNativeEnum,...z(e)});class je extends H{unwrap(){return this._def.type}_parse(e){const{ctx:t}=this._processInputParams(e);if(t.parsedType!==C.promise&&t.common.async===!1)return b(t,{code:p.invalid_type,expected:C.promise,received:t.parsedType}),R;const n=t.parsedType===C.promise?t.data:Promise.resolve(t.data);return se(n.then(i=>this._def.type.parseAsync(i,{path:t.path,errorMap:t.common.contextualErrorMap})))}}je.create=(s,e)=>new je({type:s,typeName:P.ZodPromise,...z(e)});class Ae extends H{innerType(){return this._def.schema}sourceType(){return this._def.schema._def.typeName===P.ZodEffects?this._def.schema.sourceType():this._def.schema}_parse(e){const{status:t,ctx:n}=this._processInputParams(e),i=this._def.effect||null,a={addIssue:r=>{b(n,r),r.fatal?t.abort():t.dirty()},get path(){return n.path}};if(a.addIssue=a.addIssue.bind(a),i.type==="preprocess"){const r=i.transform(n.data,a);if(n.common.async)return Promise.resolve(r).then(async o=>{if(t.value==="aborted")return R;const d=await this._def.schema._parseAsync({data:o,path:n.path,parent:n});return d.status==="aborted"?R:d.status==="dirty"||t.value==="dirty"?Ee(d.value):d});{if(t.value==="aborted")return R;const o=this._def.schema._parseSync({data:r,path:n.path,parent:n});return o.status==="aborted"?R:o.status==="dirty"||t.value==="dirty"?Ee(o.value):o}}if(i.type==="refinement"){const r=o=>{const d=i.refinement(o,a);if(n.common.async)return Promise.resolve(d);if(d instanceof Promise)throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");return o};if(n.common.async===!1){const o=this._def.schema._parseSync({data:n.data,path:n.path,parent:n});return o.status==="aborted"?R:(o.status==="dirty"&&t.dirty(),r(o.value),{status:t.value,value:o.value})}else return this._def.schema._parseAsync({data:n.data,path:n.path,parent:n}).then(o=>o.status==="aborted"?R:(o.status==="dirty"&&t.dirty(),r(o.value).then(()=>({status:t.value,value:o.value}))))}if(i.type==="transform")if(n.common.async===!1){const r=this._def.schema._parseSync({data:n.data,path:n.path,parent:n});if(!be(r))return R;const o=i.transform(r.value,a);if(o instanceof Promise)throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");return{status:t.value,value:o}}else return this._def.schema._parseAsync({data:n.data,path:n.path,parent:n}).then(r=>be(r)?Promise.resolve(i.transform(r.value,a)).then(o=>({status:t.value,value:o})):R);V.assertNever(i)}}Ae.create=(s,e,t)=>new Ae({schema:s,typeName:P.ZodEffects,effect:e,...z(t)});Ae.createWithPreprocess=(s,e,t)=>new Ae({schema:e,effect:{type:"preprocess",transform:s},typeName:P.ZodEffects,...z(t)});class he extends H{_parse(e){return this._getType(e)===C.undefined?se(void 0):this._def.innerType._parse(e)}unwrap(){return this._def.innerType}}he.create=(s,e)=>new he({innerType:s,typeName:P.ZodOptional,...z(e)});class Se extends H{_parse(e){return this._getType(e)===C.null?se(null):this._def.innerType._parse(e)}unwrap(){return this._def.innerType}}Se.create=(s,e)=>new Se({innerType:s,typeName:P.ZodNullable,...z(e)});class Ke extends H{_parse(e){const{ctx:t}=this._processInputParams(e);let n=t.data;return t.parsedType===C.undefined&&(n=this._def.defaultValue()),this._def.innerType._parse({data:n,path:t.path,parent:t})}removeDefault(){return this._def.innerType}}Ke.create=(s,e)=>new Ke({innerType:s,typeName:P.ZodDefault,defaultValue:typeof e.default=="function"?e.default:()=>e.default,...z(e)});class Ye extends H{_parse(e){const{ctx:t}=this._processInputParams(e),n={...t,common:{...t.common,issues:[]}},i=this._def.innerType._parse({data:n.data,path:n.path,parent:{...n}});return Ze(i)?i.then(a=>({status:"valid",value:a.status==="valid"?a.value:this._def.catchValue({get error(){return new oe(n.common.issues)},input:n.data})})):{status:"valid",value:i.status==="valid"?i.value:this._def.catchValue({get error(){return new oe(n.common.issues)},input:n.data})}}removeCatch(){return this._def.innerType}}Ye.create=(s,e)=>new Ye({innerType:s,typeName:P.ZodCatch,catchValue:typeof e.catch=="function"?e.catch:()=>e.catch,...z(e)});class mt extends H{_parse(e){if(this._getType(e)!==C.nan){const n=this._getOrReturnCtx(e);return b(n,{code:p.invalid_type,expected:C.nan,received:n.parsedType}),R}return{status:"valid",value:e.data}}}mt.create=s=>new mt({typeName:P.ZodNaN,...z(s)});class rs extends H{_parse(e){const{ctx:t}=this._processInputParams(e),n=t.data;return this._def.type._parse({data:n,path:t.path,parent:t})}unwrap(){return this._def.type}}class Qe extends H{_parse(e){const{status:t,ctx:n}=this._processInputParams(e);if(n.common.async)return(async()=>{const a=await this._def.in._parseAsync({data:n.data,path:n.path,parent:n});return a.status==="aborted"?R:a.status==="dirty"?(t.dirty(),Ee(a.value)):this._def.out._parseAsync({data:a.value,path:n.path,parent:n})})();{const i=this._def.in._parseSync({data:n.data,path:n.path,parent:n});return i.status==="aborted"?R:i.status==="dirty"?(t.dirty(),{status:"dirty",value:i.value}):this._def.out._parseSync({data:i.value,path:n.path,parent:n})}}static create(e,t){return new Qe({in:e,out:t,typeName:P.ZodPipeline})}}class Je extends H{_parse(e){const t=this._def.innerType._parse(e),n=i=>(be(i)&&(i.value=Object.freeze(i.value)),i);return Ze(t)?t.then(i=>n(i)):n(t)}unwrap(){return this._def.innerType}}Je.create=(s,e)=>new Je({innerType:s,typeName:P.ZodReadonly,...z(e)});var P;(function(s){s.ZodString="ZodString",s.ZodNumber="ZodNumber",s.ZodNaN="ZodNaN",s.ZodBigInt="ZodBigInt",s.ZodBoolean="ZodBoolean",s.ZodDate="ZodDate",s.ZodSymbol="ZodSymbol",s.ZodUndefined="ZodUndefined",s.ZodNull="ZodNull",s.ZodAny="ZodAny",s.ZodUnknown="ZodUnknown",s.ZodNever="ZodNever",s.ZodVoid="ZodVoid",s.ZodArray="ZodArray",s.ZodObject="ZodObject",s.ZodUnion="ZodUnion",s.ZodDiscriminatedUnion="ZodDiscriminatedUnion",s.ZodIntersection="ZodIntersection",s.ZodTuple="ZodTuple",s.ZodRecord="ZodRecord",s.ZodMap="ZodMap",s.ZodSet="ZodSet",s.ZodFunction="ZodFunction",s.ZodLazy="ZodLazy",s.ZodLiteral="ZodLiteral",s.ZodEnum="ZodEnum",s.ZodEffects="ZodEffects",s.ZodNativeEnum="ZodNativeEnum",s.ZodOptional="ZodOptional",s.ZodNullable="ZodNullable",s.ZodDefault="ZodDefault",s.ZodCatch="ZodCatch",s.ZodPromise="ZodPromise",s.ZodBranded="ZodBranded",s.ZodPipeline="ZodPipeline",s.ZodReadonly="ZodReadonly"})(P||(P={}));const S=ue.create,$=_e.create,Ne=Ue.create,vt=We.create;me.create;const Z=ie.create,ee=J.create;De.create;ze.create;pe.create;const $e=Ce.create;je.create;he.create;Se.create;const ke=ee({strength:$().int().min(1).max(30),dexterity:$().int().min(1).max(30),constitution:$().int().min(1).max(30),intelligence:$().int().min(1).max(30),wisdom:$().int().min(1).max(30),charisma:$().int().min(1).max(30)}),wt=ee({name:S().min(1),level:$().int().min(1).max(20),hitDie:$e(["d6","d8","d10","d12"]),features:Z(S()).optional(),subclass:S().optional()}),xt=ee({die:$e(["d6","d8","d10","d12"]),current:$().int().min(0),max:$().int().min(0)}),kt=ee({skill:S(),proficient:Ne(),expertise:Ne().optional(),source:S().optional()}),bt=ee({ability:S(),proficient:Ne(),source:S().optional()}),_t=ee({name:S().min(1),description:S().min(1)}),Ct=ee({name:S().min(1),description:S().min(1),source:S().min(1),uses:ee({current:$().int().min(0),max:$().int().min(0),resetOn:$e(["short_rest","long_rest","dawn"])}).optional()}),At=ee({name:S().min(1),description:S().min(1)}),St=ee({level:$().int().min(1).max(9),total:$().int().min(0),used:$().int().min(0)}),$t=ee({walking:$().int().min(0).optional(),swimming:$().int().min(0).optional(),flying:$().int().min(0).optional(),climbing:$().int().min(0).optional(),burrowing:$().int().min(0).optional()}),Tt=ee({headgear:S().optional(),armwear:S().optional(),chestwear:S().optional(),legwear:S().optional(),footwear:S().optional(),mainHand:S().optional(),offHand:S().optional(),accessories:Z(S()).optional()}),It=ee({name:S().min(1),quantity:$().int().min(1),description:S().optional(),weight:$().min(0).optional(),value:$().min(0).optional()}),Et=ee({successes:$().int().min(0).max(3),failures:$().int().min(0).max(3)});ee({name:S().min(2).max(100),race:S().min(1),subrace:S().optional(),classes:Z(wt).min(1),background:S().min(1),alignment:S().optional(),level:$().int().min(1).max(20),experiencePoints:$().int().min(0),abilityScores:ke,baseAbilityScores:ke.optional(),racialAbilityScoreImprovements:ke.optional(),hitPoints:$().int().min(1),maxHitPoints:$().int().min(1).optional(),currentHitPoints:$().int().min(0).optional(),tempHitPoints:$().int().min(0).optional(),hitDice:Z(xt).optional(),armorClass:$().int().min(1).max(30),baseArmorClass:$().int().min(1).max(30).optional(),skills:Z(S()),skillProficiencies:Z(kt).optional(),savingThrows:Z(S()),savingThrowProficiencies:Z(bt).optional(),proficiencies:Z(S()),weaponProficiencies:Z(S()).optional(),armorProficiencies:Z(S()).optional(),toolProficiencies:Z(S()).optional(),traits:Z(S()).optional(),racialTraits:Z(_t).optional(),features:Z(Ct).optional(),feats:Z(At).optional(),languages:Z(S()).optional(),speed:S().optional(),speeds:$t.optional(),initiative:$().optional(),passivePerception:$().int().min(0).optional(),passiveInvestigation:$().int().min(0).optional(),passiveInsight:$().int().min(0).optional(),spellcastingAbility:$e(["Intelligence","Wisdom","Charisma"]).optional(),spellSaveDC:$().int().min(8).max(30).optional(),spellAttackBonus:$().int().optional(),spellSlots:Z(St).optional(),spellsKnown:Z(S()).optional(),cantripsKnown:Z(S()).optional(),inspiration:Ne().optional(),deathSaves:Et.optional(),equipment:Tt.optional(),inventory:Z(It).optional(),importSource:$e(["dnd_beyond","json","pdf","manual"]).optional(),originalData:vt().optional()});ee({name:S().min(2).max(100),race:S().min(1),class:S().min(1),background:S().min(1),alignment:S().optional(),level:$().int().min(1).max(20),abilityScores:ke,hitPoints:$().int().min(1),armorClass:$().int().min(1).max(30),speed:S().optional(),skills:Z(S()),savingThrows:Z(S()),proficiencies:Z(S()),subrace:S().optional(),classes:Z(wt).optional(),baseAbilityScores:ke.optional(),racialAbilityScoreImprovements:ke.optional(),maxHitPoints:$().int().min(1).optional(),currentHitPoints:$().int().min(0).optional(),tempHitPoints:$().int().min(0).optional(),hitDice:Z(xt).optional(),baseArmorClass:$().int().min(1).max(30).optional(),skillProficiencies:Z(kt).optional(),savingThrowProficiencies:Z(bt).optional(),weaponProficiencies:Z(S()).optional(),armorProficiencies:Z(S()).optional(),toolProficiencies:Z(S()).optional(),traits:Z(S()).optional(),racialTraits:Z(_t).optional(),features:Z(Ct).optional(),feats:Z(At).optional(),languages:Z(S()).optional(),speeds:$t.optional(),initiative:$().optional(),passivePerception:$().int().min(0).optional(),passiveInvestigation:$().int().min(0).optional(),passiveInsight:$().int().min(0).optional(),spellcastingAbility:$e(["Intelligence","Wisdom","Charisma"]).optional(),spellSaveDC:$().int().min(8).max(30).optional(),spellAttackBonus:$().int().optional(),spellSlots:Z(St).optional(),spellsKnown:Z(S()).optional(),cantripsKnown:Z(S()).optional(),inspiration:Ne().optional(),deathSaves:Et.optional(),equipment:Tt.optional(),inventory:Z(It).optional(),importedFrom:S().optional(),importData:vt().optional()});function ge(s){return Math.floor((s-10)/2)}function os(s){return Math.ceil(s/4)+1}const Xe=["Artificer","Barbarian","Bard","Cleric","Druid","Fighter","Monk","Paladin","Ranger","Rogue","Sorcerer","Warlock","Wizard"],cs=["STRENGTH","DEXTERITY","CONSTITUTION","INTELLIGENCE","WISDOM","CHARISMA"],ls=["STR","DEX","CON","INT","WIS","CHA"];function ds(s,e,t){const n=[/(?:class(?:\s*&\s*level)?)[:\s]*([^\n\r]+)/i,/(?:classes?)[:\s]*([^\n\r]+)/i,/([A-Za-z\s]+)\s+(\d{1,2})\s*[\/]\s*([A-Za-z\s]+)\s+(\d{1,2})/i,/(\d{1,2})(?:st|nd|rd|th)?\s+level\s+([A-Za-z\s]+)/gi];let i=[],a=0;for(const l of n){const m=Te(s,l,{firstMatch:!1});for(const u of m){const g=u.text,f=us(g);f.length>0&&u.confidence>a&&(i=f,a=u.confidence)}}if(i.length>0){t.classes=a>.7?"high":"medium";const l=i.length>1;return e.push(`Found ${l?"multiclass":"single class"}: ${i.map(m=>`${m.name} ${m.level}`).join(", ")} (confidence: ${t.classes})`),i}const r=[],o=s.map(l=>l.rawText).join(" ");for(const l of Xe){const m=new RegExp(`\\b${l}\\s+(\\d{1,2})\\b`,"i"),u=o.match(m);if(u){const g=parseInt(u[1]);r.push({name:l,level:g,hitDie:xe(l),subclass:we(o,l),features:[]})}else o.toLowerCase().includes(l.toLowerCase())&&r.push({name:l,level:1,hitDie:xe(l),subclass:we(o,l),features:[]})}if(r.length>0)return t.classes="medium",e.push(`Found classes from document scan: ${r.map(l=>`${l.name} ${l.level}`).join(", ")} (confidence: ${t.classes})`),r;const d=Te(s,/(?:level|lvl)[:\s]*(\d+)/i,{firstMatch:!0}),c=d.length>0?parseInt(d[0].text):1;return t.classes="low",e.push(`Could not find class, using Fighter ${c} as fallback`),[{name:"Fighter",level:c,hitDie:"d10",subclass:"",features:[]}]}function us(s){const e=[],t=[/([A-Za-z]+(?:\s+[A-Za-z]+)*)\s+(\d{1,2})\s*\/\s*([A-Za-z]+(?:\s+[A-Za-z]+)*)\s+(\d{1,2})/g,/([A-Za-z\s\-]+)\s+(\d{1,2})\s*[\/,]\s*/g,/(\d+)(?:st|nd|rd|th)?\s+level\s+([A-Za-z\s\-]+)/gi,/([A-Za-z\s\-]+)\s*\((?:level\s*)?(\d{1,2})\)/gi,/(?:^|\s)([A-Za-z]+(?:\s+[A-Za-z]+)*)\s+(\d{1,2})(?:\s|$)/g];let i=/([A-Za-z]+(?:\s+[A-Za-z]+)*)\s+(\d{1,2})\s*\/\s*([A-Za-z]+(?:\s+[A-Za-z]+)*)\s+(\d{1,2})/g.exec(s);if(i){const a=qe(i[1].trim()),r=Math.max(1,Math.min(20,parseInt(i[2]))),o=qe(i[3].trim()),d=Math.max(1,Math.min(20,parseInt(i[4])));return e.push({name:a,level:r,hitDie:xe(a),subclass:we(s,a),features:[]}),e.push({name:o,level:d,hitDie:xe(o),subclass:we(s,o),features:[]}),e}for(const a of t){let r;for(a.lastIndex=0;(r=a.exec(s))!==null;){let o,d;a.source.includes("level")?(d=parseInt(r[1]),o=r[2]):(o=r[1],d=parseInt(r[2])),o=qe(o.trim()),d=Math.max(1,Math.min(20,d)),e.find(c=>c.name===o)||e.push({name:o,level:d,hitDie:xe(o),subclass:we(s,o),features:[]})}}if(e.length===0){const a=Xe.filter(r=>s.toLowerCase().includes(r.toLowerCase()));for(const r of a){const o=[new RegExp(`${r}\\s+(\\d{1,2})`,"i"),new RegExp(`(\\d{1,2})(?:st|nd|rd|th)?\\s+level\\s+${r}`,"i"),new RegExp(`${r}\\s*\\((?:level\\s*)?(\\d{1,2})\\)`,"i")];for(const d of o){const c=s.match(d);if(c){const l=parseInt(c[1]);if(l>=1&&l<=20&&!e.find(m=>m.name===r)){e.push({name:r,level:l,hitDie:xe(r),subclass:we(s,r),features:[]});break}}}}}return e}function we(s,e){const n={Fighter:[/champion/i,/battle\s*master/i,/eldritch\s*knight/i],Ranger:[/hunter/i,/beast\s*master/i,/gloom\s*stalker/i],Rogue:[/thief/i,/assassin/i,/arcane\s*trickster/i],Wizard:[/evocation/i,/divination/i,/necromancy/i,/enchantment/i],Cleric:[/life/i,/light/i,/war/i,/tempest/i],Paladin:[/devotion/i,/ancients/i,/vengeance/i],Warlock:[/fiend/i,/great\s*old\s*one/i,/archfey/i],Sorcerer:[/draconic/i,/wild\s*magic/i],Bard:[/lore/i,/valor/i],Barbarian:[/berserker/i,/totem\s*warrior/i],Druid:[/land/i,/moon/i],Monk:[/open\s*hand/i,/shadow/i,/four\s*elements/i]}[e]||[];for(const i of n)if(i.test(s)){const a=s.match(i);return a?a[0]:""}return""}function hs(s,e,t){const n={strength:10,dexterity:10,constitution:10,intelligence:10,wisdom:10,charisma:10};let i=0;for(const a of s){for(let r=0;r<a.lines.length-3;r++){const o=a.lines[r],d=a.lines[r+1],c=a.lines[r+2],l=a.lines[r+3];if(cs.some(u=>o.text.toUpperCase().includes(u))||ls.some(u=>o.text.toUpperCase().includes(u))){e.push(`Found ability score header on page ${a.pageNumber}, line ${r}: "${o.text}"`);const u=[o,d,c,l];for(const g of u)if(g){const f=ms(g);if(f){Object.assign(n,f),i=Object.values(f).filter(w=>w!==10).length,e.push(`Extracted ability scores from line: "${g.text}"`);break}}if(i>0)break}}if(i>0)break}if(i<3){e.push("Trying spatial ability score detection...");const a=fs(s,e);a&&(Object.assign(n,a),i=Object.values(a).filter(r=>r!==10).length)}if(i<3){e.push("Trying individual ability score pattern matching...");const a={strength:[/(?:strength|str)\s*[:\-]?\s*(\d+)/i,/str\s+(\d+)/i,/(\d+)\s+str/i,/strength\s+score[:\s]*(\d+)/i],dexterity:[/(?:dexterity|dex)\s*[:\-]?\s*(\d+)/i,/dex\s+(\d+)/i,/(\d+)\s+dex/i,/dexterity\s+score[:\s]*(\d+)/i],constitution:[/(?:constitution|con)\s*[:\-]?\s*(\d+)/i,/con\s+(\d+)/i,/(\d+)\s+con/i,/constitution\s+score[:\s]*(\d+)/i],intelligence:[/(?:intelligence|int)\s*[:\-]?\s*(\d+)/i,/int\s+(\d+)/i,/(\d+)\s+int/i,/intelligence\s+score[:\s]*(\d+)/i],wisdom:[/(?:wisdom|wis)\s*[:\-]?\s*(\d+)/i,/wis\s+(\d+)/i,/(\d+)\s+wis/i,/wisdom\s+score[:\s]*(\d+)/i],charisma:[/(?:charisma|cha)\s*[:\-]?\s*(\d+)/i,/cha\s+(\d+)/i,/(\d+)\s+cha/i,/charisma\s+score[:\s]*(\d+)/i]};for(const[r,o]of Object.entries(a))for(const d of o){const c=Te(s,d,{firstMatch:!0});if(c.length>0){const l=parseInt(c[0].text);if(l>=1&&l<=30){n[r]=l,i++,e.push(`Found ${r}: ${l} using pattern ${d.source}`);break}}}}return t.abilityScores=i>=4?"high":i>=2?"medium":"low",e.push(`Found ${i}/6 ability scores (confidence: ${t.abilityScores})`),n}function fs(s,e){for(const t of s){const n=[];for(const i of t.lines)for(const a of i.items){const r=a.str.toLowerCase();let o="";if(r.includes("str")||r.includes("strength")?o="strength":r.includes("dex")||r.includes("dexterity")?o="dexterity":r.includes("con")||r.includes("constitution")?o="constitution":r.includes("int")||r.includes("intelligence")?o="intelligence":r.includes("wis")||r.includes("wisdom")?o="wisdom":(r.includes("cha")||r.includes("charisma"))&&(o="charisma"),o)for(const d of t.lines)for(const c of d.items){const l=Math.abs(c.x-a.x),m=Math.abs(c.y-a.y);if(l<=100&&m<=50){const u=c.str.match(/^\d{1,2}$/);if(u){const g=parseInt(u[0]);g>=3&&g<=20&&n.push({ability:o,score:g,x:c.x,y:c.y})}}}}if(n.length>=3){const i={},a=["strength","dexterity","constitution","intelligence","wisdom","charisma"];for(const r of a){const o=n.filter(d=>d.ability===r);if(o.length>0){const d=o.filter(c=>c.score>=6&&c.score<=18);i[r]=d.length>0?d[0].score:o[0].score}}if(Object.keys(i).length>=3)return e.push(`Spatial analysis found ${Object.keys(i).length} ability scores`),i}}return null}function ms(s){const e=s.text.match(/\b(\d{1,2})\b/g);if(e&&e.length>=6){const t=e.slice(0,6).map(n=>parseInt(n)).filter(n=>n>=3&&n<=20);if(t.length>=6)return{strength:t[0],dexterity:t[1],constitution:t[2],intelligence:t[3],wisdom:t[4],charisma:t[5]}}if(e&&e.length>=3){const t=e.map(n=>parseInt(n)).filter(n=>n>=6&&n<=20);if(t.length>=3){const n={},i=["strength","dexterity","constitution","intelligence","wisdom","charisma"];for(let a=0;a<Math.min(t.length,6);a++)n[i[a]]=t[a];return n}}return null}function ps(s,e,t){const n=[/(?:hit\s*points|hp)\s*(?:maximum)?[:\s]*(\d+)/i,/(?:current\s*hit\s*points|current\s*hp)[:\s]*(\d+)/i,/(?:temporary\s*hit\s*points|temp\s*hp)[:\s]*(\d+)/i];let i=1,a=1,r=0,o=!1;for(const d of n){const c=Te(s,d,{firstMatch:!0});if(c.length>0){const l=parseInt(c[0].text);d.source.includes("current")?a=l:d.source.includes("temp")?r=l:(i=l,o||(a=l)),o=!0}}return t.hitPoints=o?"high":"low",e.push(`Hit Points - Max: ${i}, Current: ${a}, Temp: ${r} (confidence: ${t.hitPoints})`),{max:i,current:a,temp:r}}function gs(s,e,t){const n=[/(?:armor\s*class|ac)[:\s]*(\d+)/i,/(?:base\s*ac|base\s*armor\s*class)[:\s]*(\d+)/i];let i=10,a=10,r=!1;for(const o of n){const d=Te(s,o,{firstMatch:!0});if(d.length>0){const c=parseInt(d[0].text);o.source.includes("base")?a=c:(i=c,r||(a=c)),r=!0}}return t.armorClass=r?"high":"low",e.push(`Armor Class - Total: ${i}, Base: ${a} (confidence: ${t.armorClass})`),{total:i,base:a}}function ys(s,e,t){const n=[/(?:speed)[:\s]*(\d+)\s*(?:ft\.?|feet?)/i,/(?:walking)[:\s]*(\d+)\s*(?:ft\.?|feet?)/i,/(?:flying?)[:\s]*(\d+)\s*(?:ft\.?|feet?)/i,/(?:swim(?:ming)?)[:\s]*(\d+)\s*(?:ft\.?|feet?)/i,/(?:climb(?:ing)?)[:\s]*(\d+)\s*(?:ft\.?|feet?)/i],i={};let a=!1;for(const r of n){const o=Te(s,r,{firstMatch:!0});if(o.length>0){const d=parseInt(o[0].text);r.source.includes("fly")?i.flying=d:r.source.includes("swim")?i.swimming=d:r.source.includes("climb")?i.climbing=d:i.walking=d,a=!0}}return i.walking||(i.walking=30),t.speeds=a?"high":"low",e.push(`Speeds: ${Object.entries(i).map(([r,o])=>`${r}: ${o}ft`).join(", ")} (confidence: ${t.speeds})`),i}function Te(s,e,t={}){const n=[];for(const i of s){for(let a=0;a<i.lines.length;a++){const r=i.lines[a],o=t.caseSensitive?r.text:r.text.toLowerCase(),d=t.caseSensitive?e:new RegExp(e.source,e.flags.includes("i")?e.flags:e.flags+"i"),c=o.match(d);if(c){let l=.8;if(a<5&&(l+=.1),c[1]&&c[1].trim().length>0&&(l+=.1),n.push({text:c[1]||c[0],page:i.pageNumber,line:a,confidence:Math.min(1,l)}),t.firstMatch)break}}if(t.firstMatch&&n.length>0)break}return n.sort((i,a)=>a.confidence-i.confidence)}function qe(s){const e=s.trim();return Xe.find(n=>n.toLowerCase()===e.toLowerCase())||e||"Fighter"}function xe(s){return{Artificer:"d8",Barbarian:"d12",Bard:"d8",Cleric:"d8",Druid:"d8",Fighter:"d10",Monk:"d8",Paladin:"d10",Ranger:"d10",Rogue:"d8",Sorcerer:"d6",Warlock:"d8",Wizard:"d6"}[s]||"d8"}function vs(s,e,t){const n=[],i={headgear:void 0,armwear:void 0,chestwear:void 0,legwear:void 0,footwear:void 0,mainHand:void 0,offHand:void 0,accessories:[]},a={copper:0,silver:0,electrum:0,gold:0,platinum:0};let r=0;e.push("=== ENHANCED EQUIPMENT PARSING ===");const o=["longsword","shortsword","rapier","scimitar","dagger","handaxe","battleaxe","greataxe","mace","warhammer","maul","spear","javelin","halberd","glaive","pike","trident","quarterstaff","club","greatsword","flail","morningstar","war pick","whip","shortbow","longbow","light crossbow","heavy crossbow","hand crossbow","sling","dart","blowgun","net","lance","unarmed strike","unarmed","fist","eldritch blast","shocking grasp","produce flame"],d=["padded armor","leather armor","studded leather","hide armor","chain shirt","scale mail","breastplate","half plate","ring mail","chain mail","splint armor","plate armor","shield","buckler","padded","leather","studded","hide","chain","scale","plate"],c=["backpack","bedroll","blanket","rope","grappling hook","torch","lantern","oil","rations","waterskin","tinderbox","crowbar","hammer","piton","tent","manacles","chain","lock","key","spyglass","magnifying glass","caltrops","chalk","climbing kit","clothes","common","component pouch","fishing tackle","flask","grapnel","ink","paper","parchment","perfume","pick","pole","pot","iron","pouch","quiver","robes","rope","hemp","sack","scale","merchant","sealing wax","signet ring","soap","spell book","spellbook","string","tinder box","torch","travel","vial","whetstone","arrows","bolts","bullets","sling bullets","crossbow bolts"],l=["alchemist's supplies","brewer's supplies","calligrapher's supplies","carpenter's tools","cartographer's tools","cobbler's tools","cook's utensils","glassblower's tools","jeweler's tools","leatherworker's tools","mason's tools","painter's supplies","potter's tools","smith's tools","tinker's tools","weaver's tools","woodcarver's tools","thieves' tools","gaming set","musical instrument","navigator's tools","poisoner's kit","herbalism kit","healer's kit","disguise kit","forgery kit"];for(const m of s)for(let u=0;u<m.lines.length;u++){const f=m.lines[u].text.trim();if(!f||f.length<2)continue;if(/^(equipment|gear|inventory|name\s+qty|name\s+weight|item\s+qty)/i.test(f)){e.push(`Found equipment section: "${f}"`);for(let v=u+1;v<Math.min(m.lines.length,u+50);v++){const y=m.lines[v].text.trim();if(!y||y.length<2)continue;if(/^(spells?|features?|actions?|attacks?|skills?|abilities|proficiencies|additional\s+features)/i.test(y))break;const k=y.match(/^([A-Za-z\s\-,'\.\+]+?)\s+(\d+)\s+(\d+(?:\.\d+)?)\s*(?:lb|lbs?\.?)?\s*$/i);if(k){const T=k[1].trim(),B=parseInt(k[2]),N=parseFloat(k[3]),j=Oe(T,o,d,c,l);j&&(n.push({name:T,quantity:B,weight:N,type:j}),r++,e.push(`Found table equipment: ${T} x${B} (${N} lb)`))}else if(y.match(/^([A-Za-z\s\-,'\.\+]+?)\s+(\d+)\s*$/)){const T=y.match(/^([A-Za-z\s\-,'\.\+]+?)\s+(\d+)\s*$/);if(T){const B=T[1].trim(),N=parseInt(T[2]),j=Oe(B,o,d,c,l);j&&(n.push({name:B,quantity:N,type:j}),r++,e.push(`Found simple equipment: ${B} x${N}`))}}else if(y.match(/^[A-Za-z\s\-,'\.\+]+$/)){const T=Oe(y,o,d,c,l);T&&(n.push({name:y,quantity:1,type:T}),r++,e.push(`Found single equipment: ${y}`))}}}const w=f.match(/(\d+)\s*(cp|sp|ep|gp|pp|copper|silver|electrum|gold|platinum)/gi);w&&w.forEach(v=>{const[,h,y]=v.match(/(\d+)\s*(cp|sp|ep|gp|pp|copper|silver|electrum|gold|platinum)/i)||[];if(h&&y){const k=parseInt(h),T=y.toLowerCase();T.includes("cp")||T.includes("copper")?a.copper+=k:T.includes("sp")||T.includes("silver")?a.silver+=k:T.includes("ep")||T.includes("electrum")?a.electrum+=k:T.includes("gp")||T.includes("gold")?a.gold+=k:(T.includes("pp")||T.includes("platinum"))&&(a.platinum+=k),e.push(`Found currency: ${h} ${y}`)}});const _=f.toLowerCase();[...o,...d,...c,...l].forEach(v=>{if(_.includes(v)&&!n.some(h=>h.name.toLowerCase().includes(v))){const h=Oe(v,o,d,c,l);h&&(n.push({name:v,quantity:1,type:h}),r++,e.push(`Found item mention: ${v} (${h})`))}})}return t.equipment=r>=5?"high":r>=2?"medium":"low",e.push(`Enhanced equipment parsing found ${r} items (confidence: ${t.equipment})`),{inventory:n,equipment:i,currency:a}}function ws(s,e,t){const n=[],i=[],a=[];let r=0;e.push("=== ENHANCED ACTION PARSING ===");const o=["eldritch blast","shocking grasp","produce flame","magic hand","mage hand","cantrips","identify","detect magic","shield","cure wounds","healing word","fireball","lightning bolt","hold person","counterspell","dispel magic"],d=["second wind","action surge","fighting style","extra attack","flurry of blows","patient defense","step of the wind","stunning strike","ki points","unarmored defense","martial arts","deflect missiles","slow fall","wholeness of body","evasion","pact magic","otherworldly patron","eldritch invocations","hex","hexblade","weapon mastery","topple","sap","vex","push","nick","light","finesse","two-weapon fighting","alert","draconic ancestry","breath weapon","damage resistance"];for(const c of s)for(let l=0;l<c.lines.length;l++){const u=c.lines[l].text.trim();if(!u||u.length<2)continue;const g=u.match(/^([A-Za-z\s\-']+?)\s+\+?(\d+)\s+(\d+d\d+(?:[+-]\d+)?)\s+([A-Za-z]+)\s*(.*)$/i);if(g){const[,x,v,h,y,k]=g;n.push({name:x.trim(),attackBonus:parseInt(v),damage:h,damageType:y.toLowerCase(),properties:{description:k.trim()}}),r++,e.push(`Found weapon attack table entry: ${x} +${v} ${h} ${y}`)}const f=u.match(/^([A-Za-z\s\-']+)\.\s*\+?(\d+)\s+to\s+hit,?\s*(\d+d\d+(?:[+-]\d+)?)\s+([a-z]+)\s+damage/i);if(f&&!g){const[,x,v,h,y]=f;n.push({name:x.trim(),attackBonus:parseInt(v),damage:h,damageType:y,properties:{}}),r++,e.push(`Found weapon attack: ${x} +${v} to hit, ${h} ${y}`)}const w=u.match(/^([A-Za-z\s\-']+)\.\s*\+?(\d+)\s+to\s+hit,?\s*(\d+d\d+(?:[+-]\d+)?)\s+([a-z]+)\s+damage,?\s*(\d+)\s*(?:ft|feet)/i);if(w){const[,x,v,h,y,k]=w;i.push({name:x.trim(),attackBonus:parseInt(v),damage:h,damageType:y,range:`${k} ft`}),r++,e.push(`Found spell attack: ${x} +${v} to hit, ${h} ${y}, ${k} ft`)}const _=u.match(/^([A-Za-z\s\-']+)\s*(?:\(([^)]+)\))?\.\s*(.+)/i);if(_&&!f&&!w&&!g){const[,x,v,h]=_;let y;if(v){const k=v.match(/(\d+)\/(.+)/);k&&(y={current:parseInt(k[1]),max:parseInt(k[1]),resetOn:k[2].trim()})}a.push({name:x.trim(),description:h,uses:y}),r++,e.push(`Found feature action: ${x}`)}if(/^(actions?|attacks?|combat|weapon\s+attacks?|spell\s+attacks?|=== actions ===)/i.test(u)){e.push(`Found action section: "${u}"`);for(let x=l+1;x<Math.min(c.lines.length,l+50);x++){const h=c.lines[x].text.trim();if(!h||h.length<3)continue;if(/^(spells?|features?|equipment|inventory|skills?|abilities|additional\s+features)/i.test(h))break;const y=h.match(/^([A-Za-z\s\-']+)\s*(?:\(([^)]+)\))?[:\.]?\s*(.*)/);if(y){const[,k,T,B]=y,N=o.some(M=>k.toLowerCase().includes(M)),j=d.some(M=>k.toLowerCase().includes(M));N&&!i.some(M=>M.name.toLowerCase()===k.toLowerCase())?(i.push({name:k.trim(),attackBonus:0,damage:"1d4",damageType:"force",range:"60 ft"}),r++,e.push(`Found spell from section: ${k}`)):j&&!a.some(M=>M.name.toLowerCase()===k.toLowerCase())&&(a.push({name:k.trim(),description:B||`Class feature: ${k}`}),r++,e.push(`Found feature from section: ${k}`))}}}o.forEach(x=>{u.toLowerCase().includes(x)&&!i.some(v=>v.name.toLowerCase().includes(x))&&(i.push({name:x,attackBonus:0,damage:"1d4",damageType:"force",range:"60 ft"}),r++,e.push(`Found spell mention: ${x}`))}),d.forEach(x=>{u.toLowerCase().includes(x)&&!a.some(v=>v.name.toLowerCase().includes(x))&&(a.push({name:x,description:`Class feature: ${x}`}),r++,e.push(`Found feature mention: ${x}`))})}return t.actions=r>=5?"high":r>=2?"medium":"low",e.push(`Enhanced action parsing found ${r} actions (confidence: ${t.actions})`),e.push(`- Weapon attacks: ${n.length}`),e.push(`- Spell attacks: ${i.length}`),e.push(`- Feature actions: ${a.length}`),{weaponAttacks:n,spellAttacks:i,featureActions:a}}function Oe(s,e,t,n,i){const a=s.toLowerCase();return e.some(r=>r.toLowerCase()===a)?"weapon":t.some(r=>r.toLowerCase()===a)?"armor":i.some(r=>r.toLowerCase()===a)?"tool":n.some(r=>r.toLowerCase()===a)?"gear":e.some(r=>a.includes(r.toLowerCase())||r.toLowerCase().includes(a))?"weapon":t.some(r=>a.includes(r.toLowerCase())||r.toLowerCase().includes(a))?"armor":i.some(r=>a.includes(r.toLowerCase())||r.toLowerCase().includes(a))?"tool":n.some(r=>a.includes(r.toLowerCase())||r.toLowerCase().includes(a))?"gear":/(arrow|bolt|bullet|sling stone|dart)/i.test(a)?"ammunition":/(rope|torch|lantern|oil|ration|water|tent|bedroll|pack|bag|pouch|coin|money|clothes|common)/i.test(a)?"gear":/(kit|tool|instrument|thieves|lock|pick|supplies)/i.test(a)?"tool":/(potion|elixir|draught)/i.test(a)?"potion":/(book|tome|manual|scroll|spellbook)/i.test(a)?"book":/(gem|jewelry|ring|necklace|crown|gold|silver|platinum|diamond|ruby|emerald)/i.test(a)?"valuable":"gear"}Mt();function Zs(s){var G,X,ne,Y,Q,ae,re,ce,Ie;const e=[],t={},n={},i=s.map(W=>W.rawText).join(`
`);e.push(`Processing ${s.length} pages`);const a=xs(s,e,t),r=ks(s,e,t),o=bs(s,e,t),d=_s(s,e,t),c=Cs(s,e,t),l=ds(s,e,t),m=l.reduce((W,Be)=>W+Be.level,0),u=hs(s,e,t),g={strength:ge(u.strength),dexterity:ge(u.dexterity),constitution:ge(u.constitution),intelligence:ge(u.intelligence),wisdom:ge(u.wisdom),charisma:ge(u.charisma)},f=os(m),w=ps(s,e,t),_=gs(s,e,t),x=ys(s,e,t),{skills:v,skillProficiencies:h}=As(s,e,t),{savingThrows:y,savingThrowProficiencies:k}=Ss(s,e,t),{weaponProficiencies:T,armorProficiencies:B,toolProficiencies:N,languages:j}=$s(s,e,t),M=Ts(s,e,t);try{const W=vs(s,e,t);W&&W.inventory.length>M.inventory.length&&(e.push("Using enhanced equipment parsing results"),Object.assign(M,W))}catch{e.push("Enhanced equipment parsing failed, using standard results")}const{features:F,racialTraits:D}=Is(s,e,t),q=Es(s,l,g,f,e,t),I=Rs(s,e,t);try{const W=ws(s,e,t),Be=(((G=I==null?void 0:I.weaponAttacks)==null?void 0:G.length)||0)+(((X=I==null?void 0:I.spellAttacks)==null?void 0:X.length)||0)+(((ne=I==null?void 0:I.featureActions)==null?void 0:ne.length)||0),Rt=W?(((Y=W.weaponAttacks)==null?void 0:Y.length)||0)+(((Q=W.spellAttacks)==null?void 0:Q.length)||0)+(((ae=W.featureActions)==null?void 0:ae.length)||0):0;W&&Rt>Be&&(e.push("Using enhanced action parsing results"),Object.assign(I,W))}catch{e.push("Enhanced action parsing failed, using standard results")}const U=Ps(l),E=10+g.wisdom+(v.includes("Perception")?f:0),L=10+g.intelligence+(v.includes("Investigation")?f:0),O=10+g.wisdom+(v.includes("Insight")?f:0);n.rawPages=s,n.extractedText=i;const K={name:a,race:r,subrace:o,classes:l,background:d,alignment:c,level:m,experiencePoints:0,abilityScores:u,baseAbilityScores:u,hitPoints:w.current||w.max,maxHitPoints:w.max,currentHitPoints:w.current||w.max,tempHitPoints:w.temp||0,hitDice:U,armorClass:_.total,baseArmorClass:_.base,speed:x.walking?`${x.walking} ft.`:"30 ft.",speeds:x,proficiencyBonus:f,skills:v,skillProficiencies:h,savingThrows:y,savingThrowProficiencies:k,proficiencies:[...T,...B,...N],weaponProficiencies:T,armorProficiencies:B,toolProficiencies:N,languages:j,features:F,racialTraits:D,passivePerception:E,passiveInvestigation:L,passiveInsight:O,initiative:g.dexterity,equipment:M.equipment,inventory:M.inventory,...q,actions:(((re=I==null?void 0:I.weaponAttacks)==null?void 0:re.map(W=>W.name))||[]).concat(((ce=I==null?void 0:I.spellAttacks)==null?void 0:ce.map(W=>W.name))||[]).concat(((Ie=I==null?void 0:I.featureActions)==null?void 0:Ie.map(W=>W.name))||[]),parsedEquipment:M,parsedActions:I,importedFrom:"pdf",uncapturedData:n,confidence:t,parseLog:e};return e.push(`Extraction complete. Confidence: ${Object.keys(t).filter(W=>t[W]==="high").length} high, ${Object.keys(t).filter(W=>t[W]==="medium").length} medium, ${Object.keys(t).filter(W=>t[W]==="low").length} low`),K}function Me(s,e,t={}){const n=[];for(const i of s){for(let a=0;a<i.lines.length;a++){const r=i.lines[a],o=t.caseSensitive?r.text:r.text.toLowerCase(),d=t.caseSensitive?e:new RegExp(e.source,e.flags.includes("i")?e.flags:e.flags+"i"),c=o.match(d);if(c){let l=.8;if(a<5&&(l+=.1),c[1]&&c[1].trim().length>0&&(l+=.1),n.push({text:c[1]||c[0],page:i.pageNumber,line:a,confidence:Math.min(1,l)}),t.firstMatch)break}}if(t.firstMatch&&n.length>0)break}return n.sort((i,a)=>a.confidence-i.confidence)}function et(s,e){if(!s)return s;const t=[/species\s+background\s+experience\s+points/gi,/background\s+experience\s+points/gi,/species\s+background/gi,/experience\s+points/gi,/background\s+experience/gi,/species\s+experience/gi];let n=s.trim();for(const i of t)n=n.replace(i,"");switch(n=n.replace(/\s+/g," ").trim(),e){case"name":if(n.length>50||n.toLowerCase().includes("species")||n.toLowerCase().includes("background")||n.toLowerCase().includes("experience"))return"";break;case"race":if(n.length>30||n.toLowerCase().includes("background")||n.toLowerCase().includes("experience"))return"";break;case"background":if(n.length>30||n.toLowerCase().includes("species")||n.toLowerCase().includes("experience"))return"";break}return n}function xs(s,e,t){const n=[/(?:character\s*name|name)[:\s]*([^\n\r]{1,50})/i,/^([A-Z][a-z]+(?: [A-Z][a-z]+)*)\s*$/m];for(const i of n){const a=Me(s,i,{firstMatch:!0});if(a.length>0){const r=et(a[0].text,"name");if(r){const o=Ns(r);return t.name=a[0].confidence>.7?"high":"medium",e.push(`Found character name: "${o}" (confidence: ${t.name})`),o}}}for(const i of s)for(let a=0;a<Math.min(10,i.lines.length);a++){const r=i.lines[a],o=r.text.split(/\s+/);for(const d of o)if(/^[A-Z][a-z]{2,}$/.test(d)&&d.length>=3&&!["The","Character","Name","Class","Level","Race","Background","Player","Species","Experience"].includes(d))return t.name="medium",e.push(`Found potential character name: "${d}" (confidence: ${t.name})`),d;if(r.items.length>0){const d=r.items[0];if(d.str.length>=3&&/^[A-Z][a-z]+$/.test(d.str)&&!["The","Character","Name","Class","Level","Race","Background","Player","Species","Experience"].includes(d.str))return t.name="medium",e.push(`Found character name from position: "${d.str}" (confidence: ${t.name})`),d.str}}return t.name="low",e.push("Could not find character name, using default"),"Unknown Character"}function ks(s,e,t){const n=[/(?:race)[:\s]*([^\n\r]{1,30})/i,/(?:species)[:\s]*([^\n\r]{1,30})/i];for(const i of n){const a=Me(s,i,{firstMatch:!0});if(a.length>0){const r=et(a[0].text,"race");if(r){const o=Ms(r);return t.race=a[0].confidence>.7?"high":"medium",e.push(`Found race: "${o}" (confidence: ${t.race})`),o}}}return t.race="low",e.push("Could not find race, using default"),"Human"}function bs(s,e,t){const n=[/(?:subrace)[:\s]*([^\n\r]+)/i,/(?:sub-race)[:\s]*([^\n\r]+)/i];for(const i of n){const a=Me(s,i,{firstMatch:!0});if(a.length>0){const r=a[0].text.trim();if(r&&r.toLowerCase()!=="none")return t.subrace=a[0].confidence>.7?"high":"medium",e.push(`Found subrace: "${r}" (confidence: ${t.subrace})`),r}}e.push("No subrace found")}function _s(s,e,t){const n=[/(?:background)[:\s]*([^\n\r]{1,30})/i];for(const i of n){const a=Me(s,i,{firstMatch:!0});if(a.length>0){const r=et(a[0].text,"background");if(r)return t.background=a[0].confidence>.7?"high":"medium",e.push(`Found background: "${r}" (confidence: ${t.background})`),r}}return t.background="low",e.push("Could not find background, using default"),"Folk Hero"}function Cs(s,e,t){const n=[/(?:alignment)[:\s]*([^\n\r]+)/i],i=["Lawful Good","Neutral Good","Chaotic Good","Lawful Neutral","True Neutral","Chaotic Neutral","Lawful Evil","Neutral Evil","Chaotic Evil"];for(const a of n){const r=Me(s,a,{firstMatch:!0});if(r.length>0){const o=r[0].text.trim(),d=i.find(c=>c.toLowerCase()===o.toLowerCase()||o.toLowerCase().includes(c.toLowerCase().split(" ")[0])&&o.toLowerCase().includes(c.toLowerCase().split(" ")[1]));if(d)return t.alignment=r[0].confidence>.7?"high":"medium",e.push(`Found alignment: "${d}" (confidence: ${t.alignment})`),d}}e.push("No alignment found")}function As(s,e,t){const n=[],i=[];let a=0;const r=["Acrobatics","Animal Handling","Arcana","Athletics","Deception","History","Insight","Intimidation","Investigation","Medicine","Nature","Perception","Performance","Persuasion","Religion","Sleight of Hand","Stealth","Survival"];for(const o of s)for(let d=0;d<o.lines.length;d++){const l=o.lines[d].text.toLowerCase();for(const m of r){const u=m.toLowerCase(),g=[new RegExp(`\\s*${u}`,"i"),new RegExp(`\\[x\\]\\s*${u}`,"i"),new RegExp(`\\s*${u}`,"i"),new RegExp(`${u}\\s*`,"i"),new RegExp(`${u}.*proficient`,"i")];for(const f of g)if(f.test(l)&&!i.includes(m)){n.push(m),i.push(m),a++,e.push(`Found skill proficiency: ${m}`);break}if(l.includes(u)){const f=new RegExp(`${u}.*?([+-]\\d+)`,"i"),w=l.match(f);if(w&&!n.includes(m)){const _=parseInt(w[1]);_>=3&&(n.push(m),i.push(m),a++,e.push(`Inferred skill proficiency from modifier: ${m} (${_})`))}}}}for(const o of s)for(let d=0;d<o.lines.length;d++){const c=o.lines[d];if(/skills?/i.test(c.text)){const l=Math.max(0,d-2),m=Math.min(o.lines.length,d+15);for(let u=l;u<m;u++){const g=o.lines[u];for(const f of r)g.text.toLowerCase().includes(f.toLowerCase())&&!n.includes(f)&&/[]|proficient|expert/i.test(g.text)&&(n.push(f),i.push(f),a++,e.push(`Found skill in skills section: ${f}`))}}}return t.skills=a>=3?"high":a>=1?"medium":"low",e.push(`Found ${a} skill proficiencies (confidence: ${t.skills})`),{skills:n,skillProficiencies:i}}function Ss(s,e,t){const n=[],i=[];let a=0;const r=["Strength","Dexterity","Constitution","Intelligence","Wisdom","Charisma"],o=["STR","DEX","CON","INT","WIS","CHA"];for(const d of s)for(let c=0;c<d.lines.length;c++){const l=d.lines[c];if(/saving\s*throws?/i.test(l.text)){const m=Math.max(0,c-2),u=Math.min(d.lines.length,c+10);for(let g=m;g<u;g++){const f=d.lines[g];for(let w=0;w<r.length;w++){const _=r[w],x=o[w];(f.text.toLowerCase().includes(_.toLowerCase())||f.text.toLowerCase().includes(x.toLowerCase()))&&/[]|proficient/i.test(f.text)&&!i.includes(_)&&(n.push(_),i.push(_),a++,e.push(`Found saving throw proficiency: ${_}`))}}}}for(const d of s)for(let c=0;c<d.lines.length;c++){const l=d.lines[c];for(let m=0;m<r.length;m++){const u=r[m],g=o[m],f=[new RegExp(`${u}\\s*[+]\\d+`,"i"),new RegExp(`${g}\\s*[+]\\d+`,"i"),new RegExp(`${u}\\s*save`,"i")];for(const w of f)if(w.test(l.text)&&!i.includes(u)){const _=l.text.match(/[+](\d+)/);if(_){const x=parseInt(_[1]);if(x>=2){n.push(u),i.push(u),a++,e.push(`Inferred saving throw proficiency: ${u} (+${x})`);break}}}}}return t.savingThrows=a>=2?"high":a>=1?"medium":"low",e.push(`Found ${a} saving throw proficiencies (confidence: ${t.savingThrows})`),{savingThrows:n,savingThrowProficiencies:i}}function $s(s,e,t){const n=[],i=[],a=[],r=[];let o=0;const d=["Simple weapons","Martial weapons","Light armor","Medium armor","Heavy armor","Shields","Dagger","Dart","Sling","Quarterstaff","Light crossbow","Scimitar","Shortsword","Longsword","Rapier","Shortbow","Longbow"],c=["Light armor","Medium armor","Heavy armor","Shields","Leather armor","Studded leather","Chain shirt","Scale mail","Chain mail","Splint armor","Plate armor"],l=["Thieves' tools","Herbalism kit","Disguise kit","Forgery kit","Vehicles (land)","Vehicles (water)","Navigator's tools","Carpenter's tools","Smith's tools","Tinker's tools"],m=["Common","Elvish","Dwarvish","Halfling","Draconic","Giant","Gnomish","Goblin","Orc","Abyssal","Celestial","Infernal"];for(const u of s)for(let g=0;g<u.lines.length;g++){const f=u.lines[g];if(/proficienc(?:y|ies)/i.test(f.text)||/languages?/i.test(f.text)){const w=Math.max(0,g),_=Math.min(u.lines.length,g+20);for(let x=w;x<_;x++){const v=u.lines[x].text;for(const h of d)v.toLowerCase().includes(h.toLowerCase())&&!n.includes(h)&&(n.push(h),o++,e.push(`Found weapon proficiency: ${h}`));for(const h of c)v.toLowerCase().includes(h.toLowerCase())&&!i.includes(h)&&(i.push(h),o++,e.push(`Found armor proficiency: ${h}`));for(const h of l)v.toLowerCase().includes(h.toLowerCase())&&!a.includes(h)&&(a.push(h),o++,e.push(`Found tool proficiency: ${h}`));for(const h of m)v.toLowerCase().includes(h.toLowerCase())&&!r.includes(h)&&(r.push(h),o++,e.push(`Found language: ${h}`))}}}for(const u of s)for(const g of u.lines){const f=g.text;if(/equipment|gear|items/i.test(f))for(const w of d)f.toLowerCase().includes(w.toLowerCase())&&!n.includes(w)&&(n.push(w),o++,e.push(`Inferred weapon proficiency from equipment: ${w}`));if(/languages?|speak|read|write/i.test(f))for(const w of m)f.toLowerCase().includes(w.toLowerCase())&&!r.includes(w)&&(r.push(w),o++,e.push(`Found language from traits: ${w}`))}return t.proficiencies=o>=3?"high":o>=1?"medium":"low",e.push(`Found ${o} total proficiencies (confidence: ${t.proficiencies})`),{weaponProficiencies:n,armorProficiencies:i,toolProficiencies:a,languages:r}}function Ts(s,e,t){const n=[],i=[],a=[],r=[],o=[],d=[],c=[],l=[],m={},u=[],g={accessories:[]};let f=0;e.push("Parsing equipment and items...");const w=(F,D,q,I,U,E,L,O)=>{u.push({name:F,quantity:q,type:D,weight:I,value:U,description:E});const K={name:F,type:D,quantity:q,weight:I,value:U,notes:E,equipped:L||!1,properties:O};switch(D){case"weapon":n.push(K);break;case"armor":i.push(K);break;case"tool":r.push(K);break;case"ammunition":o.push(K);break;case"potion":d.push(K);break;case"book":c.push(K);break;case"valuable":l.push(K);break;default:a.push(K);break}ye(F,D,g,e),f++},_=["Dagger","Dart","Handaxe","Javelin","Light Hammer","Mace","Quarterstaff","Sickle","Spear","Light Crossbow","Shortbow","Sling","Battleaxe","Flail","Glaive","Greataxe","Greatsword","Halberd","Lance","Longsword","Maul","Morningstar","Pike","Rapier","Scimitar","Shortsword","Trident","War Pick","Warhammer","Whip","Blowgun","Hand Crossbow","Heavy Crossbow","Longbow","Net","Crossbow","Bow","Sword","Axe","Hammer","Staff","Club","Mace","Spear","Polearm","Halberd","Glaive","Pike","Lance","Rapier","Scimitar","Dagger","Throwing","Ranged","Melee","Simple","Martial","Exotic"],x=["Leather armor","Studded leather","Hide armor","Chain shirt","Scale mail","Breastplate","Half plate","Ring mail","Chain mail","Splint armor","Plate armor","Shield","Buckler","Padded","Leather","Studded","Hide","Chain","Scale","Breastplate","Half","Ring","Splint","Plate","Helmet","Gauntlets","Greaves","Boots","Gloves","Bracers","Girdle","Cloak","Robe","Vest","Tunic"],v=["Backpack","Bedroll","Blanket","Rope","Grappling hook","Torch","Lantern","Oil flask","Rations","Waterskin","Tinderbox","Crowbar","Hammer","Piton","Tent","Manacles","Chain","Lock","Key","Spyglass","Magnifying glass","Sealing wax","Signet ring","Parchment","Ink","Ink pen","Quill","Bag","Pouch","Sack","Chest","Trunk","Barrel","Cask","Bottle","Vial","Flask","Cup","Bowl","Plate","Utensil","Tool","Kit","Set","Pack","Bundle"],h=["Thieves' tools","Artisan tools","Disguise kit","Forgery kit","Herbalism kit","Poisoner kit","Alchemist supplies","Brewer supplies","Calligrapher supplies","Carpenter tools","Cartographer tools","Cobbler tools","Cook utensils","Glassblower tools","Jeweler tools","Leatherworker tools","Mason tools","Painter supplies","Potter tools","Smith tools","Tinker tools","Weaver tools","Woodcarver tools","Navigator tools","Gaming set","Musical instrument","Tool","Kit","Supplies","Equipment","Instrument","Set"],y=["Arrow","Bolt","Dart","Bullet","Pellet","Stone","Rock","Shuriken","Javelin","Spear","Dagger","Axe","Hammer","Mace","Club","Staff","Quiver","Case","Pouch","Bundle","Pack","Set"],k=["Potion","Elixir","Tonic","Brew","Draught","Philter","Tincture","Healing","Cure","Restore","Enhance","Boost","Protection","Resistance"],T=["Book","Tome","Manual","Guide","Text","Scroll","Grimoire","Spellbook","Journal","Diary","Ledger","Ledger","Map","Chart","Diagram","Blueprint"],B=["Gem","Jewel","Crystal","Pearl","Diamond","Ruby","Sapphire","Emerald","Gold","Silver","Platinum","Copper","Electrum","Ingot","Bar","Coin","Ring","Necklace","Bracelet","Crown","Tiara","Medallion","Amulet"],N=[/^additional\s+equipment/i,/^equipment/i,/^gear/i,/^inventory/i,/^possessions/i,/^carrying/i,/^wearing/i,/^wielding/i,/^armed/i,/^equipped/i,/^belongings/i,/^stuff/i,/^things/i,/^tools/i,/^weapons/i,/^armor/i,/^items?/i,/^stuff/i,/^belongings/i],j=[/^item\s+quantity\s+weight\s+value/i,/^equipment\s+quantity\s+weight/i,/^gear\s+quantity/i,/^name\s+amount\s+weight/i,/^description\s+qty\s+wt/i,/^name\s+qty\s+weight/i],M=[/^[-]\s+/,/^\d+\.\s+/,/^[a-z]\)\s+/i,/^[a-z]\.\s+/i,/^[ivx]+\.\s+/i,/^[A-Z]\.\s+/];e.push("=== SEARCHING FOR EQUIPMENT SECTIONS ===");for(const F of s)for(let D=0;D<F.lines.length;D++){const I=F.lines[D].text.trim();I.length>2&&I.length<100&&e.push(`Line ${D}: "${I}"`)}for(const F of s)for(let D=0;D<F.lines.length;D++){const I=F.lines[D].text;if((N.some(E=>E.test(I))||j.some(E=>E.test(I))||M.some(E=>E.test(I)))&&I.length<=100){e.push(`Found equipment section at line ${D}: "${I}"`);const E=D+1,L=Math.min(F.lines.length,D+100);for(let O=E;O<L;O++){const G=F.lines[O].text.trim();if(!G||G.length<2)continue;if(/^(SPELLS?|FEATURES?|ACTIONS?|ATTACKS?|SKILLS?|PROFICIENCIES?|LANGUAGES?|ADDITIONAL\s+FEATURES)/i.test(G))break;const X=G.match(/^([A-Za-z\s\-']+?)\s+(\d+)\s+([\d.]+)\s*(?:lb|pound|weight)?/i);if(X){const Y=X[1].trim(),Q=parseInt(X[2]),ae=parseFloat(X[3]),re=le(Y,_,x,v,h,y,k,T,B);re&&(w(Y,re,Q,ae,void 0,void 0,!0),e.push(`Found D&D Beyond equipment: ${Y} (${Q}) - ${ae} lb`))}const ne=G.match(/^([A-Za-z\s\-']+?)\s*(?:\(([^)]+)\))?\s*(?:\(([^)]+)\))?/);if(ne&&!X){const Y=ne[1].trim(),Q=ne[2]||"",ae=ne[3]||"";let re=1,ce="";/^\d+$/.test(Q)?(re=parseInt(Q),ce=ae):Q&&!/^\d+$/.test(Q)&&(ce=Q);const Ie=le(Y,_,x,v,h,y,k,T,B);Ie&&(w(Y,Ie,re,void 0,void 0,ce||void 0,!0),e.push(`Found equipment with quantity: ${Y} (${re})${ce?` - ${ce}`:""}`))}else if(!X&&!ne){const Y=le(G,_,x,v,h,y,k,T,B);Y&&!u.some(Q=>Q.name.toLowerCase()===G.toLowerCase())&&(u.push({name:G,quantity:1,type:Y}),ye(G,Y,g,e),f++,e.push(`Found equipment: ${G} (${Y})`))}if(M.some(Y=>Y.test(G))){const Y=G.replace(/^[-]\s+/,"").replace(/^\d+\.\s+/,"").replace(/^[a-z]\)\s+/i,"").replace(/^[a-z]\.\s+/i,"").replace(/^[ivx]+\.\s+/i,"").replace(/^[A-Z]\.\s+/,"").trim(),Q=le(Y,_,x,v,h,y,k,T,B);Q&&!u.some(ae=>ae.name.toLowerCase()===Y.toLowerCase())&&(u.push({name:Y,quantity:1,type:Q}),ye(Y,Q,g,e),f++,e.push(`Found bulleted equipment: ${Y} (${Q})`))}}}}for(const F of s)for(const D of F.lines){const q=D.text.trim();if(/^[A-Za-z\s\-']+\s+\+\d+\s+to\s+hit/i.test(q)){const U=q.match(/^([A-Za-z\s\-']+)/);if(U){const E=U[1].trim();if(!u.some(L=>L.name.toLowerCase()===E.toLowerCase())){const L=le(E,_,x,v,h,y,k,T,B);L&&(u.push({name:E,quantity:1,type:L,description:"Found in weapon attacks section"}),ye(E,L,g,e),f++,e.push(`Found weapon from attack table: ${E}`))}}}if(/wearing|wielding|carrying|equipped\s+with|armed\s+with|has|owns|possesses/i.test(q)){const U=[..._,...x,...v,...h,...y,...k,...T,...B];for(const E of U)if(q.toLowerCase().includes(E.toLowerCase())&&!u.some(L=>L.name.toLowerCase()===E.toLowerCase())){const L=le(E,_,x,v,h,y,k,T,B);L&&(u.push({name:E,quantity:1,type:L,description:"Mentioned as equipped"}),ye(E,L,g,e),f++,e.push(`Found equipped item: ${E}`))}}const I=[/(\d+)\s*(gold|silver|copper|platinum|gp|sp|cp|pp|ep)/i,/(\d+)\s*(gold\s+pieces?|silver\s+pieces?|copper\s+pieces?|platinum\s+pieces?|electrum\s+pieces?)/i,/(\d+)\s*(gp|sp|cp|pp|ep)\s*coins?/i,/(\d+)\s*coins?\s*(gold|silver|copper|platinum|electrum)/i];for(const U of I){const E=q.match(U);if(E){const L=parseInt(E[1]),O=E[2].toLowerCase(),K=O==="gp"||O==="gold"?"Gold pieces":O==="sp"||O==="silver"?"Silver pieces":O==="cp"||O==="copper"?"Copper pieces":O==="pp"||O==="platinum"?"Platinum pieces":O==="ep"||O==="electrum"?"Electrum pieces":`${O.charAt(0).toUpperCase()+O.slice(1)} pieces`;O==="gp"||O==="gold"?m.gold=(m.gold||0)+L:O==="sp"||O==="silver"?m.silver=(m.silver||0)+L:O==="cp"||O==="copper"?m.copper=(m.copper||0)+L:O==="pp"||O==="platinum"?m.platinum=(m.platinum||0)+L:(O==="ep"||O==="electrum")&&(m.electrum=(m.electrum||0)+L),u.some(G=>G.name.toLowerCase().includes(O))||(u.push({name:K,quantity:L,type:"currency"}),f++,e.push(`Found currency: ${L} ${K}`))}}}e.push("Performing comprehensive item scan...");for(const F of s)for(const D of F.lines){const q=D.text.trim();if(q.length<3||q.length>200)continue;const I=[/^([A-Za-z\s\-']+?)\s*\((\d+)\)/i,/^([A-Za-z\s\-']+?)\s*\(([^)]+)\)/i,/^([A-Za-z\s\-']+?)\s*\+\d+/i,/^([A-Za-z\s\-']+?)\s*\d+d\d+/i,/^([A-Za-z\s\-']+?)\s*:\s*/i,/^([A-Za-z\s\-']+?)\s*-\s*/i,/^([A-Za-z\s\-']+?)\s*\.\s*/i,/^([A-Za-z\s\-']+?)\s*$/i];for(const U of I){const E=q.match(U);if(E){const L=E[1].trim();if(L.length<2||L.length>50||u.some(K=>K.name.toLowerCase()===L.toLowerCase())||/^(name|race|class|level|background|alignment|ability|skill|proficiency|feature|trait|spell|action|attack|defense|combat|equipment|gear|inventory|possessions|carrying|wearing|wielding|armed|equipped|belongings|stuff|things|tools|weapons|armor|items?|stuff|belongings)$/i.test(L))continue;const O=le(L,_,x,v,h,y,k,T,B);if(O){let K=1;const G=q.match(/\((\d+)\)/);G&&(K=parseInt(G[1]));let X="";const ne=q.match(/[:\-\.]\s*(.+)/);ne&&(X=ne[1].trim()),w(L,O,K,void 0,void 0,X||void 0,!1),e.push(`Found item via comprehensive scan: ${L} (${O})`);break}}}}e.push("Performing final fallback item scan...");for(const F of s)for(const D of F.lines){const q=D.text.trim();if(q.length<3||q.length>150)continue;const I=q.match(/^([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s*$/);if(I){const U=I[1].trim();if(U.length<2||U.length>30||u.some(L=>L.name.toLowerCase()===U.toLowerCase())||/^(Name|Race|Class|Level|Background|Alignment|Ability|Skill|Proficiency|Feature|Trait|Spell|Action|Attack|Defense|Combat|Equipment|Gear|Inventory|Possessions|Carrying|Wearing|Wielding|Armed|Equipped|Belongings|Stuff|Things|Tools|Weapons|Armor|Items?|Stuff|Belongings|Yes|No|True|False|Current|Maximum|Temp|Temporary|Bonus|Modifier|Score|Points|Hit|Points|Armor|Class|Speed|Initiative|Passive|Perception|Investigation|Insight|Strength|Dexterity|Constitution|Intelligence|Wisdom|Charisma)$/i.test(U))continue;const E=le(U,_,x,v,h,y,k,T,B);E&&(u.push({name:U,quantity:1,type:E}),ye(U,E,g,e),f++,e.push(`Found standalone item via fallback scan: ${U} (${E})`))}}return t.equipment=f>=5?"high":f>=2?"medium":"low",e.push(`Found ${f} pieces of equipment (confidence: ${t.equipment})`),{weapons:n,armor:i,gear:a,tools:r,ammunition:o,potions:d,books:c,valuables:l,currency:m,inventory:u,equipment:g}}function le(s,e,t,n,i,a,r,o,d){const c=s.toLowerCase();return e.some(l=>l.toLowerCase()===c)?"weapon":t.some(l=>l.toLowerCase()===c)?"armor":i.some(l=>l.toLowerCase()===c)?"tool":a.some(l=>l.toLowerCase()===c)?"ammunition":r.some(l=>l.toLowerCase()===c)?"potion":o.some(l=>l.toLowerCase()===c)?"book":d.some(l=>l.toLowerCase()===c)?"valuable":e.some(l=>l.toLowerCase().includes(c)||c.includes(l.toLowerCase()))?"weapon":t.some(l=>l.toLowerCase().includes(c)||c.includes(l.toLowerCase()))?"armor":i.some(l=>l.toLowerCase().includes(c)||c.includes(l.toLowerCase()))?"tool":a.some(l=>l.toLowerCase().includes(c)||c.includes(l.toLowerCase()))?"ammunition":r.some(l=>l.toLowerCase().includes(c)||c.includes(l.toLowerCase()))?"potion":o.some(l=>l.toLowerCase().includes(c)||c.includes(l.toLowerCase()))?"book":d.some(l=>l.toLowerCase().includes(c)||c.includes(l.toLowerCase()))?"valuable":n.some(l=>l.toLowerCase().includes(c)||c.includes(l.toLowerCase()))?"gear":null}function ye(s,e,t,n){const i=s.toLowerCase();e==="armor"&&(i.includes("helmet")||i.includes("hat")||i.includes("crown")||i.includes("cap")||i.includes("hood")?t.headgear||(t.headgear=s,n.push(`Assigned ${s} to headgear slot`)):i.includes("gloves")||i.includes("gauntlets")||i.includes("bracers")||i.includes("vambraces")?t.armwear||(t.armwear=s,n.push(`Assigned ${s} to armwear slot`)):i.includes("breastplate")||i.includes("chain")||i.includes("leather")||i.includes("scale")||i.includes("plate")||i.includes("mail")?t.chestwear||(t.chestwear=s,n.push(`Assigned ${s} to chestwear slot`)):i.includes("boots")||i.includes("shoes")||i.includes("greaves")||i.includes("sabatons")?t.footwear||(t.footwear=s,n.push(`Assigned ${s} to footwear slot`)):(i.includes("shield")||i.includes("buckler"))&&(t.offHand||(t.offHand=s,n.push(`Assigned ${s} to off-hand slot`)))),e==="weapon"&&(t.mainHand?!t.offHand&&!i.includes("two-handed")&&!i.includes("versatile")&&(t.offHand=s,n.push(`Assigned ${s} to off-hand slot`)):(t.mainHand=s,n.push(`Assigned ${s} to main hand slot`))),(e==="valuable"||e==="book"||e==="tool")&&(t.accessories.includes(s)||(t.accessories.push(s),n.push(`Added ${s} to accessories`)))}function Is(s,e,t){const n=[],i=[];let a=0;const r=["Action Surge","Second Wind","Fighting Style","Extra Attack","Indomitable","Rage","Reckless Attack","Danger Sense","Feral Instinct","Brutal Critical","Bardic Inspiration","Jack of All Trades","Song of Rest","Cutting Words","Countercharm","Spellcasting","Divine Domain","Channel Divinity","Destroy Undead","Divine Strike","Wild Shape","Druidcraft","Timeless Body","Beast Spells","Archdruid","Monk Training","Martial Arts","Ki","Unarmored Defense","Stunning Strike","Divine Sense","Lay on Hands","Divine Smite","Aura of Protection","Cleansing Touch","Favored Enemy","Natural Explorer","Hunters Mark","Primeval Awareness","Vanish","Sneak Attack","Thieves Cant","Cunning Action","Uncanny Dodge","Evasion","Sorcerous Origin","Font of Magic","Metamagic","Sorcerous Restoration","Otherworldly Patron","Pact Magic","Eldritch Invocations","Pact Boon","Mystic Arcanum","Arcane Recovery","Ritual Casting","Arcane Tradition","Spell Mastery","Signature Spells"],o=["Darkvision","Keen Senses","Fey Ancestry","Trance","Elf Weapon Training","Dwarven Resilience","Dwarven Combat Training","Stonecunning","Dwarven Armor Training","Lucky","Brave","Halfling Nimbleness","Naturally Stealthy","Draconic Ancestry","Breath Weapon","Damage Resistance","Gnome Cunning","Speak with Small Beasts","Natural Illusionist","Skill Versatility","Extra Language","Extra Skill","Relentless Endurance","Savage Attacks","Hellish Resistance","Infernal Legacy","Healing Hands","Light Bearer","Celestial Resistance","Stones Endurance","Powerful Build","Mountain Born"],d=["Feature:","Specialty:","Variant:","Guild Membership","Retainers","Position of Privilege","Shelter of the Faithful","Discovery","Researcher","City Secrets","Folk Hero","Rustic Hospitality","Ship's Passage","Bad Reputation","Criminal Contact"];e.push("Parsing features and traits...");for(const c of s)for(let l=0;l<c.lines.length;l++){const u=c.lines[l].text;if(/features?\s*(&|and)?\s*traits?/i.test(u)||/class\s*features?/i.test(u)||/racial\s*traits?/i.test(u)||/abilities?\s*(&|and)?\s*features?/i.test(u)){e.push(`Found features section at line ${l}: "${u}"`);const g=l+1,f=Math.min(c.lines.length,l+30);for(let w=g;w<f;w++){const _=c.lines[w];if(!_.text.trim()||_.text.trim().length<3)continue;if(/^(EQUIPMENT|ATTACKS?|SPELLS?|INVENTORY)/i.test(_.text))break;const x=_.text.trim();if(/^[A-Z][A-Za-z\s]+[.:]\s*/.test(x)){const v=x.match(/^([A-Z][A-Za-z\s]+)[.:]\s*(.*)/);if(v){const h=v[1].trim(),y=v[2].trim();r.some(k=>k.toLowerCase().includes(h.toLowerCase())||h.toLowerCase().includes(k.toLowerCase()))?(n.push({name:h,description:y||"Class feature",source:"class"}),a++,e.push(`Found class feature: ${h}`)):o.some(k=>k.toLowerCase().includes(h.toLowerCase())||h.toLowerCase().includes(k.toLowerCase()))?(i.push({name:h,description:y||"Racial trait"}),a++,e.push(`Found racial trait: ${h}`)):d.some(k=>k.toLowerCase().includes(h.toLowerCase())||h.toLowerCase().includes(k.toLowerCase()))?(n.push({name:h,description:y||"Background feature",source:"background"}),a++,e.push(`Found background feature: ${h}`)):(n.push({name:h,description:y||"Feature",source:"unknown"}),a++,e.push(`Found generic feature: ${h}`))}}for(const v of r)x.toLowerCase().includes(v.toLowerCase())&&!n.some(h=>h.name.toLowerCase().includes(v.toLowerCase()))&&(n.push({name:v,description:"Class feature mentioned in text",source:"class"}),a++,e.push(`Found mentioned class feature: ${v}`));for(const v of o)x.toLowerCase().includes(v.toLowerCase())&&!i.some(h=>h.name.toLowerCase().includes(v.toLowerCase()))&&(i.push({name:v,description:"Racial trait mentioned in text"}),a++,e.push(`Found mentioned racial trait: ${v}`))}}}for(const c of s)for(const l of c.lines){const m=l.text;if(/can\s+use|once\s+per|recharge|regain|expend|spend/i.test(m)){const u=m.split(/\s+/);for(let g=0;g<u.length-1;g++){const f=u[g];if(/^[A-Z][a-z]+$/.test(f)&&f.length>3)for(const w of r)w.toLowerCase().includes(f.toLowerCase())&&!n.some(_=>_.name.toLowerCase().includes(w.toLowerCase()))&&(n.push({name:w,description:"Feature mentioned in context",source:"class"}),a++,e.push(`Found context feature: ${w}`))}}}return t.features=a>=3?"high":a>=1?"medium":"low",e.push(`Found ${a} features and traits (confidence: ${t.features})`),{features:n,racialTraits:i}}function Es(s,e,t,n,i,a){const r=[];let o=0;i.push("Parsing spellcasting information...");for(const d of s)for(let c=0;c<d.lines.length;c++){const m=d.lines[c].text;if(/spells?|spellcasting|magic/i.test(m)&&/class|level|ability|modifier/i.test(m)){i.push(`Found spellcasting section at line ${c}: "${m}"`);const u=c+1,g=Math.min(d.lines.length,c+40);let f="",w=0,_="";for(let x=u;x<g;x++){const v=d.lines[x];if(!v.text.trim())continue;if(/^(EQUIPMENT|ATTACKS?|INVENTORY|FEATURES)/i.test(v.text))break;const h=v.text.trim();for(const y of e)if(h.toLowerCase().includes(y.name.toLowerCase())){f=y.name,w=y.level,i.push(`Found spellcasting class: ${f} (level ${w})`);break}if(/spellcasting\s+ability|spell\s+ability/i.test(h)){const y=h.match(/(strength|dexterity|constitution|intelligence|wisdom|charisma)/i);y&&(_=y[1].toLowerCase(),i.push(`Found spellcasting ability: ${_}`))}if(/cantrips?|spells\s+known|spells\s+prepared/i.test(h)){const y=h.match(/(\d+)\s+(cantrips?|spells?)/i);if(y&&f){const k=parseInt(y[1]),T=y[2].toLowerCase();let B=r.find(N=>N.class===f);B||(B={class:f,level:w,spellcastingAbility:_||"intelligence",spells:[]},r.push(B)),B.spells.push({type:T,count:k,level:T==="cantrips"?0:1}),o++,i.push(`Found ${k} ${T} for ${f}`)}}}}}for(const d of s)for(const c of d.lines){const l=c.text;if(/^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s*\([0-9]+\)/i.test(l)){const m=l.match(/^([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s*\(([0-9]+)\)/i);if(m){const u=m[1].trim(),g=parseInt(m[2]);for(const f of e)if(f.name&&l.toLowerCase().includes(f.name.toLowerCase())){let w=r.find(_=>_.class===f.name);w||(w={class:f.name,level:f.level,spellcastingAbility:"intelligence",spells:[]},r.push(w)),w.spells.push({name:u,level:g,type:g===0?"cantrip":"spell"}),o++,i.push(`Found spell: ${u} (level ${g}) for ${f.name}`);break}}}}for(const d of e)if(d.name&&["Wizard","Sorcerer","Warlock","Cleric","Druid","Bard","Paladin","Ranger","Artificer"].includes(d.name)&&!r.find(c=>c.class===d.name)){const c=d.name==="Wizard"||d.name==="Artificer"?"intelligence":d.name==="Cleric"||d.name==="Druid"?"wisdom":"charisma";r.push({class:d.name,level:d.level,spellcastingAbility:c,spells:[]}),o++,i.push(`Inferred spellcasting for ${d.name} (${c})`)}return a.spellcasting=o>=2?"high":o>=1?"medium":"low",i.push(`Found ${o} spellcasting entries (confidence: ${a.spellcasting})`),r}function Rs(s,e,t){const n=[],i=[],a=[];let r=0;e.push("Parsing actions and attacks...");const o={ammunition:/ammunition|loading|reload/i,finesse:/finesse/i,heavy:/heavy/i,light:/light/i,loading:/loading/i,range:/range|thrown/i,reach:/reach/i,thrown:/thrown/i,"two-handed":/two.?handed|versatile/i,versatile:/versatile/i,special:/special/i,martial:/martial/i,simple:/simple/i,exotic:/exotic/i},d=[/^[-]\s+/,/^\d+\.\s+/,/^[a-z]\)\s+/i,/^[a-z]\.\s+/i,/^[ivx]+\.\s+/i,/^[A-Z]\.\s+/,/^\|\s+/];e.push("=== SEARCHING FOR ACTION SECTIONS ===");for(const l of s)for(let m=0;m<l.lines.length;m++){const g=l.lines[m].text.trim();(g.toLowerCase().includes("attack")||g.toLowerCase().includes("action")||g.toLowerCase().includes("weapon")||g.toLowerCase().includes("spell")||g.toLowerCase().includes("damage"))&&g.length>5&&g.length<200&&e.push(`Action candidate line ${m}: "${g}"`)}const c=[/^actions?/i,/^weapon\s+attacks?/i,/^spell\s+attacks?/i,/^cantrips?/i,/^attacks?/i,/^combat\s+actions?/i,/^standard\s+actions?/i,/^bonus\s+actions?/i,/^reactions?/i,/^features?\s+&\s+traits/i,/^additional\s+features?\s+&\s+traits/i];for(const l of s)for(let m=0;m<l.lines.length;m++){const g=l.lines[m].text;if(c.some(w=>w.test(g))&&g.length<=100){e.push(`Found action section at line ${m}: "${g}"`);const w=m+1,_=Math.min(l.lines.length,m+120);for(let x=w;x<_;x++){const h=l.lines[x].text.trim();if(!h||h.length<2)continue;if(/^(SPELLS?|FEATURES?|EQUIPMENT|GEAR|ITEMS|INVENTORY|SKILLS?|PROFICIENCIES?|LANGUAGES?|ADDITIONAL\s+FEATURES)/i.test(h))break;const y=h.match(/^([A-Za-z\s\-']+?)\s+(?:(\+?\d+)\s+)?(?:to\s+hit|attack\s+bonus|bonus)?\s*(?:,?\s*)?(?:(\d+d\d+(?:\+\d+)?)\s+)?([a-z]+)\s+damage/i);if(y){const N=y[1].trim(),j=y[2]?parseInt(y[2]):0,M=y[3]||"1d4",F=y[4]||"bludgeoning",D={};for(const[U,E]of Object.entries(o))E.test(h)&&(D[U]=!0);const q=h.match(/(\d+)\s*(?:feet?|ft)/i),I=q?`${q[1]} ft`:void 0;n.push({name:N,attackBonus:j,damage:M,damageType:F,range:I,properties:D}),r++,e.push(`Found weapon attack: ${N} +${j} to hit, ${M} ${F} damage`)}const k=h.match(/^([A-Za-z\s\-']+?)\s+(?:(\+?\d+)\s+)?(?:to\s+hit|attack\s+bonus|bonus)?\s*(?:,?\s*)?(?:(\d+d\d+(?:\+\d+)?)\s+)?([a-z]+)\s+damage\s*(?:,?\s*)?(?:(\d+)\s*(?:feet?|ft))?/i);if(k){const N=k[1].trim(),j=k[2]?parseInt(k[2]):0,M=k[3]||"1d4",F=k[4]||"force",D=k[5]?`${k[5]} ft`:"60 ft";i.push({name:N,attackBonus:j,damage:M,damageType:F,range:D}),r++,e.push(`Found spell attack: ${N} +${j} to hit, ${M} ${F} damage, ${D}`)}const T=h.match(/^\|\s*([A-Za-z\s\-']+?)\s*(?:\(([^)]+)\))?\s*:?\s*(.+)/i);if(T&&!y&&!k){const N=T[1].trim();T[2];const j=T[3]||"";let M="Action";/bonus\s+action/i.test(j)?M="Bonus Action":/reaction/i.test(j)?M="Reaction":/free\s+action/i.test(j)&&(M="Free Action");let F;const D=j.match(/(\d+)\s*\/\s*(.+?)(?:\s|$)/i);if(D){const G=parseInt(D[1]),X=D[2].trim();F={current:G,max:G,resetOn:X}}const q=j.match(/(\d+d\d+(?:\+\d+)?)\s+([a-z]+)/i),I=q?q[1]:void 0,U=q?q[2]:void 0,E=j.match(/DC\s+(\d+)/i),L=E?parseInt(E[1]):void 0,O=j.match(/(\d+)\s*(?:feet?|ft)/i),K=O?`${O[1]} ft`:void 0;a.push({name:N,description:`${M}: ${j}`,damage:I,damageType:U,saveDC:L,range:K,uses:F}),r++,e.push(`Found pipe action: ${N} (${M}) - ${j}`)}const B=h.match(/^([A-Za-z\s\-']+?)\s*(?:\(([^)]+)\))?\s*:?\s*(.+)/i);if(B&&!y&&!k&&!T){const N=B[1].trim(),j=B[2]||void 0,M=B[3]||"";let F;if(j){const K=j.match(/(\d+)\/(.+)/);if(K){const G=parseInt(K[1]),X=K[2].trim();F={current:G,max:G,resetOn:X}}}const D=M.match(/(\d+d\d+(?:\+\d+)?)\s+([a-z]+)/i),q=D?D[1]:void 0,I=D?D[2]:void 0,U=M.match(/DC\s+(\d+)/i),E=U?parseInt(U[1]):void 0,L=M.match(/(\d+)\s*(?:feet?|ft)/i),O=L?`${L[1]} ft`:void 0;a.push({name:N,description:M,damage:q,damageType:I,saveDC:E,range:O,uses:F}),r++,e.push(`Found feature action: ${N}${F?` (${F})`:""} - ${M}`)}else if(d.some(N=>N.test(h))&&!y&&!k&&!T&&!B){const N=h.replace(/^[-]\s+/,"").replace(/^\d+\.\s+/,"").replace(/^[a-z]\)\s+/i,"").replace(/^[a-z]\.\s+/i,"").replace(/^[ivx]+\.\s+/i,"").replace(/^[A-Z]\.\s+/,"").replace(/^\|\s+/,"").trim();y||k||(a.push({name:N,description:"Action from character sheet"}),r++,e.push(`Found bulleted action: ${N}`))}}}}for(const l of s)for(const m of l.lines){const u=m.text.trim();if(/can\s+attack\s+with|wields?|casts?|uses?|has\s+the\s+ability\s+to/i.test(u)){const g=["attack","cast","use","wield","throw","shoot","strike","slash","pierce","bludgeon"];for(const f of g)if(u.toLowerCase().includes(f)){const w=u.match(new RegExp(`([A-Za-z\\s\\-']+?)\\s+${f}`,"i"));if(w){const _=w[1].trim();a.some(x=>x.name.toLowerCase()===_.toLowerCase())||(a.push({name:_,description:`Can ${f} with ${_}`}),r++,e.push(`Found mentioned action: ${_} (${f})`))}}}if(/damage|attack\s+bonus|to\s+hit/i.test(u)){const g=["sword","axe","hammer","bow","crossbow","dagger","spear","staff","mace","flail","glaive","halberd","lance","rapier","scimitar","trident","whip"];for(const f of g)if(u.toLowerCase().includes(f)&&!n.some(w=>w.name.toLowerCase().includes(f))){const w=u.match(/(\+?\d+)/),_=w?parseInt(w[1]):0,x=u.match(/(\d+d\d+(?:\+\d+)?)/),v=x?x[1]:"1d4",h=u.match(/(slashing|piercing|bludgeoning|fire|cold|lightning|thunder|acid|poison|necrotic|radiant|force|psychic)/i),y=h?h[1]:"bludgeoning";n.push({name:f.charAt(0).toUpperCase()+f.slice(1),attackBonus:_,damage:v,damageType:y,properties:{}}),r++,e.push(`Found weapon from context: ${f} +${_} to hit, ${v} ${y} damage`)}}}e.push("Performing comprehensive action scan...");for(const l of s)for(const m of l.lines){const u=m.text.trim();if(u.length<3||u.length>200)continue;const g=[/^([A-Za-z\s\-']+?)\s*\(([^)]+)\)/i,/^([A-Za-z\s\-']+?)\s*:\s*/i,/^([A-Za-z\s\-']+?)\s*-\s*/i,/^([A-Za-z\s\-']+?)\s*\.\s*/i,/^([A-Za-z\s\-']+?)\s*\+\d+/i,/^([A-Za-z\s\-']+?)\s*\d+d\d+/i,/^([A-Za-z\s\-']+?)\s*to\s+hit/i,/^([A-Za-z\s\-']+?)\s*damage/i];for(const f of g){const w=u.match(f);if(w){const _=w[1].trim();if(_.length<2||_.length>50||n.some(N=>N.name.toLowerCase()===_.toLowerCase())||i.some(N=>N.name.toLowerCase()===_.toLowerCase())||a.some(N=>N.name.toLowerCase()===_.toLowerCase())||/^(name|race|class|level|background|alignment|ability|skill|proficiency|feature|trait|spell|action|attack|defense|combat|equipment|gear|inventory|possessions|carrying|wearing|wielding|armed|equipped|belongings|stuff|things|tools|weapons|armor|items?|stuff|belongings)$/i.test(_))continue;let x="feature",v=0,h="",y="",k="";if(u.toLowerCase().includes("to hit")||u.toLowerCase().includes("attack bonus")){x="weapon";const N=u.match(/(\+?\d+)/);v=N?parseInt(N[1]):0;const j=u.match(/(\d+d\d+(?:\+\d+)?)/);h=j?j[1]:"";const M=u.match(/(slashing|piercing|bludgeoning|fire|cold|lightning|thunder|acid|poison|necrotic|radiant|force|psychic)/i);y=M?M[1]:"";const F=u.match(/(\d+)\s*(?:feet?|ft)/i);k=F?`${F[1]} ft`:""}else if(u.toLowerCase().includes("spell")||u.toLowerCase().includes("magic")||u.toLowerCase().includes("cantrip")){x="spell";const N=u.match(/(\+?\d+)/);v=N?parseInt(N[1]):0;const j=u.match(/(\d+d\d+(?:\+\d+)?)/);h=j?j[1]:"";const M=u.match(/(slashing|piercing|bludgeoning|fire|cold|lightning|thunder|acid|poison|necrotic|radiant|force|psychic)/i);y=M?M[1]:"";const F=u.match(/(\d+)\s*(?:feet?|ft)/i);k=F?`${F[1]} ft`:"60 ft"}let T="";const B=u.match(/[:\-\.]\s*(.+)/);B&&(T=B[1].trim()),x==="weapon"?(n.push({name:_,attackBonus:v,damage:h||"1d4",damageType:y||"bludgeoning",range:k||void 0,properties:{}}),e.push(`Found weapon action via comprehensive scan: ${_}`)):x==="spell"?(i.push({name:_,attackBonus:v,damage:h||"1d4",damageType:y||"force",range:k||"60 ft"}),e.push(`Found spell action via comprehensive scan: ${_}`)):(a.push({name:_,description:T||`Action: ${_}`,damage:h||void 0,damageType:y||void 0,range:k||void 0}),e.push(`Found feature action via comprehensive scan: ${_}`)),r++;break}}}return t.actions=r>=5?"high":r>=2?"medium":"low",e.push(`Found ${r} actions (confidence: ${t.actions})`),{weaponAttacks:n,spellAttacks:i,featureActions:a}}function Ps(s){const e=new Map;return s.forEach(t=>{const n=t.hitDie,i=e.get(n)||0;e.set(n,i+t.level)}),Array.from(e.entries()).map(([t,n])=>({die:t,current:n,max:n}))}function Ns(s){return s.replace(/[^\w\s\-']/g,"").replace(/\s+/g," ").trim()}function Ms(s){const e=s.trim();return["Human","Elf","Dwarf","Halfling","Dragonborn","Gnome","Half-Elf","Half-Orc","Tiefling","Aasimar","Genasi","Goliath","Tabaxi"].find(i=>i.toLowerCase()===e.toLowerCase())||e||"Human"}export{Zs as extractCharacterDataFromStructuredPages};
